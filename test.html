<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>PDFビューア：カルーセル＆虫眼鏡（新仕様）</title>
    <style>
      :root {
        --gap: 8px;
        --thumbW: 110px;
        --thumbH: 78px;
        --ring: 3px;
      }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica,
          Arial, "Noto Sans JP", sans-serif;
        background: #0b1220;
        color: #e5e7eb;
      }
      .wrap {
        max-width: 1100px;
        margin: auto;
        padding: 12px;
      }
      .viewer {
        position: relative;
        background: #0f172a;
        border-radius: 12px;
        overflow: hidden;
        aspect-ratio: 3 / 2; /* ビューア比率はお好みで */
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .viewer img#pageImage {
        max-width: 100%;
        max-height: 100%;
        display: block;
        user-select: none;
        -webkit-user-drag: none;
      }

      /* 虫眼鏡 */
      .loupe {
        position: absolute;
        inset: auto auto auto auto;
        display: none; /* トグルで表示 / 非表示（サンプルではボタンで）*/
        overflow: hidden;
        border-radius: 16px;
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.2);
        touch-action: none; /* 1本指ドラッグ可能に */
        backdrop-filter: saturate(120%);
      }
      .loupe.active {
        display: block;
      }
      .loupe img {
        position: absolute;
        left: 0;
        top: 0;
        will-change: transform;
        user-select: none;
        -webkit-user-drag: none;
        pointer-events: none;
      }
      .loupe .hint {
        position: absolute;
        right: 8px;
        bottom: 6px;
        font-size: 12px;
        opacity: 0.7;
      }

      /* カルーセル */
      .carousel {
        margin-top: 14px;
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 8px;
        align-items: center;
      }
      .bar {
        position: relative;
        overflow: auto hidden;
        scroll-behavior: smooth;
        border-radius: 8px;
        background: #0f172a;
        padding: 8px;
      }
      .list {
        display: flex;
        gap: var(--gap);
        /* snap は任意 */
      }
      .thumb {
        flex: 0 0 auto;
        width: var(--thumbW);
        height: var(--thumbH);
        background: #111827;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
        outline: 1px solid rgba(255, 255, 255, 0.07);
        cursor: pointer;
      }
      .thumb img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .thumb .idx {
        position: absolute;
        left: 6px;
        top: 6px;
        font-size: 12px;
        opacity: 0.8;
        background: rgba(0, 0, 0, 0.4);
        padding: 0.15rem 0.35rem;
        border-radius: 6px;
      }
      /* 現在地リング */
      .thumb.current::after {
        content: "";
        position: absolute;
        inset: calc(-1 * var(--ring));
        border: var(--ring) solid #22c55e;
        border-radius: 12px;
        box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.25) inset;
      }

      /* ボタン */
      .btn {
        appearance: none;
        border: none;
        background: #111827;
        color: #e5e7eb;
        padding: 0.6rem 0.7rem;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 700;
        min-width: 44px;
      }
      .btn:active {
        transform: translateY(1px);
      }
      .row {
        display: flex;
        gap: 6px;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h2 style="margin: 6px 2px 10px; font-weight: 700">
        PDFビューア（新仕様デモ）
      </h2>

      <div class="viewer" id="viewer">
        <img id="pageImage" src="https://picsum.photos/1200/800" alt="page" />
        <div id="loupe" class="loupe">
          <img id="loupeImg" alt="" />
          <div class="hint">
            ドラッグで一時移動／指を離すと最寄りの隅にスナップ
          </div>
        </div>
      </div>

      <div class="row">
        <button class="btn" id="toggleLoupe">虫眼鏡 ON/OFF</button>
      </div>

      <div class="carousel">
        <button class="btn" id="btnFastPrev">«</button>
        <div class="bar" id="bar">
          <div class="list" id="list"></div>
        </div>
        <button class="btn" id="btnFastNext">»</button>
      </div>
      <div class="row">
        <button class="btn" id="btnPrev">←</button>
        <button class="btn" id="btnNext">→</button>
      </div>
    </div>

    <script>
      /************** データ（ダミー） **************/
      const PAGES = Array.from({ length: 24 }, (_, i) => ({
        idx: i,
        src: `https://picsum.photos/seed/${i + 1}/600/400`,
      }));

      /************** カルーセル：現在地常時可視（←/→） **************/
      const bar = document.getElementById("bar");
      const list = document.getElementById("list");
      const btnPrev = document.getElementById("btnPrev");
      const btnNext = document.getElementById("btnNext");
      const btnFastPrev = document.getElementById("btnFastPrev");
      const btnFastNext = document.getElementById("btnFastNext");

      let current = 0;

      function renderList() {
        list.innerHTML = "";
        for (const p of PAGES) {
          const el = document.createElement("div");
          el.className = "thumb" + (p.idx === current ? " current" : "");
          el.dataset.idx = p.idx;
          el.innerHTML = `<img src="${p.src}" alt="">
                      <span class="idx">${p.idx + 1}</span>`;
          el.addEventListener("click", () => {
            setCurrent(p.idx, { ensureVisible: true });
          });
          list.appendChild(el);
        }
      }

      function getThumb(idx) {
        return list.querySelector(`.thumb[data-idx="${idx}"]`);
      }

      function setCurrent(
        idx,
        { ensureVisible = false, placeAtEdge = false, scroll = false } = {}
      ) {
        idx = Math.max(0, Math.min(PAGES.length - 1, idx));
        current = idx;
        list
          .querySelectorAll(".thumb")
          .forEach((t) =>
            t.classList.toggle("current", Number(t.dataset.idx) === current)
          );
        if (ensureVisible) {
          keepCurrentVisible(placeAtEdge);
        } else if (scroll) {
          // << / >> ではスクロールしない（＝非表示を許容） → 要望どおり
        }
      }

      // 現在地を常時表示：必要時にスクロール
      function keepCurrentVisible(placeAtEdge = false) {
        const t = getThumb(current);
        if (!t) return;
        const tRect = t.getBoundingClientRect();
        const bRect = bar.getBoundingClientRect();
        const overLeft = tRect.left < bRect.left;
        const overRight = tRect.right > bRect.right;
        if (overLeft || overRight) {
          if (placeAtEdge) {
            // 現在地を端に“とどめたまま”バーだけ送る感覚に近づける
            const delta = overLeft
              ? tRect.left - bRect.left // 負
              : tRect.right - bRect.right; // 正
            bar.scrollLeft += delta; // 端で固定される感覚
          } else {
            // 単純に fully visible までスクロール
            t.scrollIntoView({
              block: "nearest",
              inline: overLeft ? "start" : "end",
              behavior: "smooth",
            });
          }
        }
      }

      // ←/→：現在地は常に見えるように（端に来たら端で留めつつバーを送る）
      btnPrev.addEventListener("click", () => {
        const before = current;
        setCurrent(current - 1, { ensureVisible: true, placeAtEdge: true });
        if (before === current) {
          keepCurrentVisible(true);
        } // 0から左に打った場合の保険
      });
      btnNext.addEventListener("click", () => {
        const before = current;
        setCurrent(current + 1, { ensureVisible: true, placeAtEdge: true });
        if (before === current) {
          keepCurrentVisible(true);
        } // 末尾から右に打った場合の保険
      });

      // « »：非表示も許容（＝スクロールしない）
      btnFastPrev.addEventListener("click", () => {
        setCurrent(Math.max(0, current - 5), { scroll: false });
      });
      btnFastNext.addEventListener("click", () => {
        setCurrent(Math.min(PAGES.length - 1, current + 5), { scroll: false });
      });

      // 初期描画
      renderList();
      // 最初は中央付近が見えるよう軽くスクロール
      setTimeout(() => {
        keepCurrentVisible();
      }, 0);

      /************** 虫眼鏡：4分割 & 4隅スナップ **************/
      const viewer = document.getElementById("viewer");
      const pageImg = document.getElementById("pageImage");
      const loupe = document.getElementById("loupe");
      const loupeImg = document.getElementById("loupeImg");
      const toggle = document.getElementById("toggleLoupe");

      // 画面の2/3サイズに調整（常に viewer の 2/3）
      function sizeLoupe() {
        const r = viewer.getBoundingClientRect();
        const w = Math.round((r.width * 2) / 3);
        const h = Math.round((r.height * 2) / 3);
        loupe.style.width = w + "px";
        loupe.style.height = h + "px";
      }

      // 現在の隅（'tl'|'tr'|'bl'|'br'）と、ドラッグ中は位置から動的判定
      function quadrantFromCenter(cx, cy) {
        const r = viewer.getBoundingClientRect();
        const midX = r.left + r.width / 2;
        const midY = r.top + r.height / 2;
        const horiz = cx < midX ? "l" : "r";
        const vert = cy < midY ? "t" : "b";
        return vert + horiz; // 'tl' など
      }

      // 指を離したら最寄りの隅へスナップ
      function snapToNearestCorner() {
        const vr = viewer.getBoundingClientRect();
        const lr = loupe.getBoundingClientRect();
        const corners = [
          { q: "tl", x: vr.left, y: vr.top },
          { q: "tr", x: vr.right - lr.width, y: vr.top },
          { q: "bl", x: vr.left, y: vr.bottom - lr.height },
          { q: "br", x: vr.right - lr.width, y: vr.bottom - lr.height },
        ];
        const cx = lr.left + lr.width / 2,
          cy = lr.top + lr.height / 2;
        let best = null,
          bestD = Infinity;
        for (const c of corners) {
          const dx = c.x + lr.width / 2 - cx;
          const dy = c.y + lr.height / 2 - cy;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD) {
            bestD = d2;
            best = c;
          }
        }
        loupe.style.left = Math.round(best.x - vr.left) + "px";
        loupe.style.top = Math.round(best.y - vr.top) + "px";
        updateLoupeContent(best.q);
      }

      // 4分の1領域を虫眼鏡サイズに拡大表示
      function updateLoupeContent(q) {
        // 表示中画像の実表示サイズを取得
        const ir = pageImg.getBoundingClientRect();
        const vr = viewer.getBoundingClientRect();
        const lW = loupe.clientWidth,
          lH = loupe.clientHeight;

        // 画像が viewer の中でオフセットされている分も考慮
        const imgW = ir.width,
          imgH = ir.height;
        // 四分の一矩形の左上座標（画像表示領域内）
        const srcX = q.endsWith("l") ? 0 : imgW / 2;
        const srcY = q.startsWith("t") ? 0 : imgH / 2;
        const srcW = imgW / 2,
          srcH = imgH / 2;

        // その四分の一を虫眼鏡の枠いっぱいに埋めるスケール
        const sx = lW / srcW;
        const sy = lH / srcH;

        // loupe 内に同じ画像を配置し、拡大＋オフセット
        loupeImg.src = pageImg.src;
        loupeImg.style.width = Math.round(imgW * sx) + "px";
        loupeImg.style.height = Math.round(imgH * sy) + "px";

        // viewer 内での画像の左上を基準に、四分の一の開始点をズラす
        const offsetX = ir.left - vr.left; // viewer基準の画像原点X
        const offsetY = ir.top - vr.top; // viewer基準の画像原点Y

        const left = Math.round(-srcX * sx + -offsetX * sx);
        const top = Math.round(-srcY * sy + -offsetY * sy);

        loupeImg.style.transform = `translate(${left}px, ${top}px)`;
      }

      // 位置更新（ドラッグ中はどこでも存在OK）
      let dragging = false,
        grabDX = 0,
        grabDY = 0;
      function startDrag(clientX, clientY) {
        dragging = true;
        const vr = viewer.getBoundingClientRect();
        const lr = loupe.getBoundingClientRect();
        grabDX = clientX - lr.left;
        grabDY = clientY - lr.top;
        // ドラッグ開始時、現在の象限プレビュー
        const q = quadrantFromCenter(
          lr.left + lr.width / 2,
          lr.top + lr.height / 2
        );
        updateLoupeContent(q);
      }
      function moveDrag(clientX, clientY) {
        if (!dragging) return;
        const vr = viewer.getBoundingClientRect();
        let x = clientX - grabDX - vr.left;
        let y = clientY - grabDY - vr.top;
        // viewer 内だけ動けるようクランプ
        x = Math.max(0, Math.min(x, vr.width - loupe.clientWidth));
        y = Math.max(0, Math.min(y, vr.height - loupe.clientHeight));
        loupe.style.left = Math.round(x) + "px";
        loupe.style.top = Math.round(y) + "px";
        // 現在中心の位置から象限を判定して内容更新
        const lr = loupe.getBoundingClientRect();
        const q = quadrantFromCenter(
          lr.left + lr.width / 2,
          lr.top + lr.height / 2
        );
        updateLoupeContent(q);
      }
      function endDrag() {
        if (!dragging) return;
        dragging = false;
        snapToNearestCorner();
      }

      // 4隅に初期配置
      function placeLoupeAt(q = "tr") {
        sizeLoupe();
        const vr = viewer.getBoundingClientRect();
        const lw = loupe.clientWidth,
          lh = loupe.clientHeight;
        let x = 0,
          y = 0;
        if (q.endsWith("r")) x = vr.width - lw;
        if (q.startsWith("b")) y = vr.height - lh;
        loupe.style.left = x + "px";
        loupe.style.top = y + "px";
        updateLoupeContent(q);
      }

      // ON/OFF
      toggle.addEventListener("click", () => {
        loupe.classList.toggle("active");
        if (loupe.classList.contains("active")) {
          placeLoupeAt("tr"); // 右上に出す
        }
      });

      // ポインタイベント（マウス・タッチ共通）
      loupe.addEventListener("pointerdown", (e) => {
        loupe.setPointerCapture(e.pointerId);
        startDrag(e.clientX, e.clientY);
      });
      loupe.addEventListener("pointermove", (e) => {
        moveDrag(e.clientX, e.clientY);
      });
      loupe.addEventListener("pointerup", (e) => {
        loupe.releasePointerCapture(e.pointerId);
        endDrag();
      });
      loupe.addEventListener("pointercancel", () => endDrag());

      // リサイズ時にサイズ再計算＆スナップ維持
      const ro = new ResizeObserver(() => {
        if (!loupe.classList.contains("active")) return;
        const lr = loupe.getBoundingClientRect();
        const centerX = lr.left + lr.width / 2;
        const centerY = lr.top + lr.height / 2;
        const q = quadrantFromCenter(centerX, centerY);
        placeLoupeAt(q);
      });
      ro.observe(viewer);

      window.addEventListener("load", () => {
        sizeLoupe();
        placeLoupeAt("tr");
      });
      window.addEventListener("resize", sizeLoupe);
    </script>
  </body>
</html>
