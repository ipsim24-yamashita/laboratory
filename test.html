<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- ブラウザ標準ズームは無効（自前ピンチのみ） -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>GENESIS 解答ビューア</title>

  <!-- Tailwind CSS CDN（色は以前と同じ） -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            linegreen: '#22c55e',
            carYellow: '#fde047'
          }
        }
      }
    }
  </script>

  <style>
    /* 画面全体の“ビヨーン”抑止 & 横スクロール禁止 */
    html, body { overscroll-behavior-y: contain; overflow-x: hidden; }
    body { -webkit-user-select: none; user-select: none; }

    /* ── 固定カルーセル ─────────────────────────── */
    .toc-dock { position: fixed; top: 0; left: 0; right: 0; z-index: 2000;
      background:#fff; border-bottom:1px solid #e5e7eb; padding:8px 0; }
    /* カルーセル自身はピンチ禁止、横スクロールだけ許可 */
    .toc { height:44px; overflow-x:auto; overflow-y:hidden; white-space:nowrap;
      touch-action: pan-x; -webkit-overflow-scrolling: touch; }
    .toc::-webkit-scrollbar{ height:6px; }

    /* ページチップの見切れ対策 */
    .toc-list { display:flex; gap:8px; padding:0 8px; align-items:center; }

    /* ── 本文（ピンチ対象） ───────────────────────── */
    #content { max-width: 100%; margin: 0 auto; padding: 0 12px; }
    /* ズーム対象ラッパ */
    #zoom-area { transform-origin: 0 0; will-change: transform; touch-action: pan-y; }
    /* 横スクロールは常に禁止（縦だけ） */
    #zoom-area { overflow-x: hidden; }
    /* ページ画像 */
    .page-frame { position: relative; overflow:hidden;
      width: 100vw; max-width: 100vw;
      margin-left: calc(50% - 50vw); margin-right: calc(50% - 50vw);
      border:1px solid #e5e7eb; border-radius:12px; background:#fff; }
    .page-img { display:block; width:100%; height:auto; pointer-events:none; -webkit-user-drag:none; }

    /* ボタン色など */
    .btn-yellow { height:36px; padding:0 12px; border:1px solid #facc15; background:#fde047; color:#111; border-radius:9999px; }
  </style>
</head>
<body class="bg-white text-neutral-900">

  <!-- ── 固定カルーセル（ピンチ禁止 / 横スクロール可） ── -->
  <div id="toc-dock" class="toc-dock">
    <div class="max-w-full mx-auto px-3">
      <div class="flex items-center gap-2">
        <button id="car-prev" class="btn-yellow">≪</button>
        <button id="car-next" class="btn-yellow">≫</button>

        <nav id="toc" class="toc flex-1 min-w-0">
          <ul id="toc-list" class="toc-list"></ul>
        </nav>

        <button id="pg-prev" class="btn-yellow">←</button>
        <button id="pg-next" class="btn-yellow">→</button>
        <a id="btn-open" href="#" target="_blank" rel="noopener"
           class="h-9 px-3 rounded-full bg-neutral-100 text-neutral-900 border border-neutral-300 inline-flex items-center justify-center">Tab</a>
      </div>
    </div>
  </div>

  <!-- ── 本文（ピンチ対象） ── -->
  <main id="content">
    <div id="zoom-area"></div>
  </main>

  <script>
    /* ========= データ ========= */
    const BASE = "docs/";
    const groups = [
      { prefix: "1-", start: 1, end: 15 },
      { prefix: "2-", start: 1, end: 12 },
      { prefix: "3-", start: 1, end: 11 },
    ];
    const pad3 = (n) => String(n).padStart(3, "0");
    const files = groups.flatMap(g => Array.from({length:g.end-g.start+1},(_,i)=>`${g.prefix}${pad3(g.start+i)}.jpeg`));

    /* ========= 要素 ========= */
    const tocDock = document.getElementById('toc-dock');
    const tocEl   = document.getElementById('toc');
    const tocList = document.getElementById('toc-list');
    const zoomArea= document.getElementById('zoom-area');
    const content = document.getElementById('content');
    const btnOpen = document.getElementById('btn-open');
    const pgPrev  = document.getElementById('pg-prev');
    const pgNext  = document.getElementById('pg-next');
    const carPrev = document.getElementById('car-prev');
    const carNext = document.getElementById('car-next');

    /* ========= DOM生成 ========= */
    files.forEach((name, idx) => {
      // chip
      const li=document.createElement('li');
      const a=document.createElement('a');
      a.href=`#p-${name.replace(/\.[^.]+$/,'')}`;
      a.dataset.index=idx;
      a.textContent=name.replace('.jpeg','');
      a.className="inline-block px-3 py-1.5 border rounded-full select-none whitespace-nowrap border-neutral-300 bg-blue-50 text-blue-600";
      if(idx===0) a.classList.add("bg-linegreen","text-white","border-green-600");
      li.appendChild(a); tocList.appendChild(li);

      // section
      const sec=document.createElement('section');
      sec.id=`p-${name.replace(/\.[^.]+$/,'')}`;
      sec.className="py-4 border-b border-neutral-100";
      sec.innerHTML=`
        <figure class="page-frame">
          <img class="page-img" src="${BASE}${encodeURIComponent(name)}" alt="">
        </figure>`;
      zoomArea.appendChild(sec);
    });

    /* ========= 固定バー高さを本文に反映 ========= */
    function applyDockPad(){
      const h=tocDock.offsetHeight||60;
      content.style.paddingTop=(h+12)+'px';
    }
    new ResizeObserver(applyDockPad).observe(tocDock);
    window.addEventListener('resize',applyDockPad);
    applyDockPad();

    /* ========= 現在ページ検出 ========= */
    const sections=Array.from(document.querySelectorAll('main section'));
    const tocLinks=Array.from(document.querySelectorAll('#toc-list a'));
    let currentIndex=0;

    function setActive(i, ensureVisible=false){
      currentIndex=i;
      tocLinks.forEach((el,idx)=>{
        el.classList.toggle("bg-linegreen",idx===i);
        el.classList.toggle("text-white",idx===i);
        el.classList.toggle("border-green-600",idx===i);
        el.classList.toggle("bg-blue-50",idx!==i);
        el.classList.toggle("text-blue-600",idx!==i);
        el.classList.toggle("border-neutral-300",idx!==i);
      });
      const img=sections[i]?.querySelector('img');
      if(img) btnOpen.href=img.currentSrc||img.src;

      if(ensureVisible){
        const link=tocLinks[i], lr=link.getBoundingClientRect(), tr=tocEl.getBoundingClientRect();
        if(lr.left<tr.left) tocEl.scrollLeft+=lr.left-tr.left;
        else if(lr.right>tr.right) tocEl.scrollLeft+=lr.right-tr.right;
      }
    }
    function detectCurrentPage(){
      const baseline=tocDock.getBoundingClientRect().bottom;
      let idx=0;
      for(let i=0;i<sections.length;i++){
        const r=sections[i].getBoundingClientRect();
        const th=r.top+r.height*0.6;
        if(baseline>=th) idx=i+1;
      }
      const last=sections[sections.length-1].getBoundingClientRect();
      if(last.bottom<=window.innerHeight) idx=sections.length-1;
      if(idx>=sections.length) idx=sections.length-1;
      if(idx!==currentIndex) setActive(idx,false);
    }
    window.addEventListener('scroll',detectCurrentPage,{passive:true});
    window.addEventListener('resize',detectCurrentPage);
    window.addEventListener('load',detectCurrentPage);

    /* ========= ページ送り ========= */
    function scrollToSection(i, ensureVisible=false){
      const s=sections[i]; if(!s) return;
      window.scrollTo({ top:s.offsetTop, behavior:'auto' });
      requestAnimationFrame(()=>{ detectCurrentPage(); if(ensureVisible) setActive(i,true); });
    }
    pgPrev.onclick=()=>{ const next=Math.max(0,currentIndex-1); scrollToSection(next,true); };
    pgNext.onclick=()=>{ const next=Math.min(sections.length-1,currentIndex+1); scrollToSection(next,true); };

    /* ========= カルーセル左右（横スクロール可） ========= */
    function pageSize(){ const tr=tocEl.getBoundingClientRect(); return Math.max(200,tr.width*0.8); }
    let carTimer=null;
    function startCarScroll(dir){ if(carTimer) return; const step=Math.round(pageSize()*0.25); const tick=()=>tocEl.scrollBy({left:dir*step,behavior:'auto'}); tick(); carTimer=setInterval(tick,60); }
    function stopCarScroll(){ if(carTimer){ clearInterval(carTimer); carTimer=null; } }
    ['pointerup','pointercancel','pointerleave','touchend'].forEach(ev=>{ carPrev.addEventListener(ev,stopCarScroll); carNext.addEventListener(ev,stopCarScroll); });
    carPrev.addEventListener('pointerdown',e=>{ e.preventDefault(); startCarScroll(-1); });
    carNext.addEventListener('pointerdown',e=>{ e.preventDefault(); startCarScroll(+1); });
    tocLinks.forEach(a=>a.onclick=(e)=>{ e.preventDefault(); scrollToSection(Number(a.dataset.index), true); });

    /* ========= 本文ピンチズーム（最大2× / 安定描画） ========= */
    initGlobalZoom(); // ←呼び出し

    function initGlobalZoom(){
      const area = document.getElementById('zoom-area');
      if(!area) return;

      let scale=1, tx=0, ty=0;
      let startScale=1, startTx=0, startTy=0;
      let startDist=0, startMid={x:0,y:0};
      const pts=new Map();
      const MIN_SCALE=1, MAX_SCALE=2;

      const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
      const mid =(a,b)=>({x:(a.x+b.x)/2, y:(a.y+b.y)/2});
      const apply=()=>{ area.style.transform=`translate(${tx}px, ${ty}px) scale(${scale})`; };

      // ブラウザのジェスチャ無効化（自前のみ）
      ['gesturestart','gesturechange','gestureend'].forEach(t=>{
        area.addEventListener(t, e=>e.preventDefault(), {passive:false});
      });
      // 全体でダブル/トリプルクリック禁止
      let lastClick=0, clickCount=0;
      window.addEventListener('click', (e)=>{
        const now=Date.now();
        if(now-lastClick<400) clickCount++; else clickCount=1;
        lastClick=now;
        if(clickCount>=2){ e.preventDefault(); e.stopPropagation(); }
      }, true);

      // ズーム対象は常に自前処理（水平スクロール禁止）
      area.style.touchAction='pan-y';

      area.addEventListener('pointerdown', e=>{
        area.setPointerCapture(e.pointerId);
        pts.set(e.pointerId,{x:e.clientX,y:e.clientY});
        if(pts.size===2){
          const [p1,p2]=[...pts.values()];
          startDist=dist(p1,p2)||1;
          startMid =mid(p1,p2);
          startScale=scale;
          startTx=tx; startTy=ty;
          // ピンチ開始時は縦スクロールも止める
          area.style.touchAction='none';
          document.body.style.overflow='hidden';
        }else if(pts.size===1){
          startMid={x:e.clientX,y:e.clientY};
        }
      });

      area.addEventListener('pointermove', e=>{
        if(!pts.has(e.pointerId)) return;
        pts.set(e.pointerId,{x:e.clientX,y:e.clientY});

        if(pts.size===2){
          // ピンチ（中心固定）
          const [p1,p2]=[...pts.values()];
          const curDist=dist(p1,p2)||1;
          let nextScale=startScale*(curDist/(startDist||1));
          nextScale=Math.max(MIN_SCALE, Math.min(MAX_SCALE, nextScale));

          const rect=area.getBoundingClientRect();
          const md=mid(p1,p2);
          const mx=md.x-rect.left, my=md.y-rect.top;

          const preX=(mx-startTx)/startScale;
          const preY=(my-startTy)/startScale;
          tx = mx - preX*nextScale;
          ty = my - preY*nextScale;

          scale=nextScale;
          apply();
        }else if(pts.size===1){
          const p=[...pts.values()][0];
          const dx=p.x-startMid.x;
          const dy=p.y-startMid.y;
          startMid={x:p.x,y:p.y};

          if(scale>1){
            // 拡大中はパン（横方向もOKだが“スクロール”ではない）
            tx+=dx; ty+=dy; apply();
          }else{
            // 等倍時は縦スクロールのみ
            window.scrollBy(0,-dy);
          }
        }
      });

      const endPointer=(e)=>{
        pts.delete(e.pointerId);
        if(pts.size===1) startMid=[...pts.values()][0];
        if(pts.size===0){
          area.style.touchAction='pan-y';
          document.body.style.overflow=''; // スクロール解放
        }
      };
      ['pointerup','pointercancel','pointerleave'].forEach(ev=>{
        area.addEventListener(ev,endPointer);
      });

      // ホイール/トラックパッド：拡大中のみパンに割り当て
      area.addEventListener('wheel', (e)=>{
        if(scale>1){
          e.preventDefault();
          tx -= e.deltaX;
          ty -= e.deltaY;
          apply();
        }
      }, {passive:false});

      apply();
    }

    /* 初期アクティブ */
    setActive(0,false);
  </script>
</body>
</html>