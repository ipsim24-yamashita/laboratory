<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- ブラウザ標準ズームは無効（自前ピンチのみ） -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>GENESIS 解答ビューア</title>

  <!-- Tailwind CSS CDN（色は以前と同じ） -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            linegreen: '#22c55e',
            carYellow: '#fde047'
          }
        }
      }
    }
  </script>

  <style>
    /* 画面全体の“ビヨーン”抑止 & 横スクロール禁止 */
    html, body { overscroll-behavior-y: contain; overflow-x: hidden; }
    body { -webkit-user-select: none; user-select: none; }

    /* ── 固定カルーセル ─────────────────────────── */
    .toc-dock { position: fixed; top: 0; left: 0; right: 0; z-index: 2000;
      background:#fff; border-bottom:1px solid #e5e7eb; padding:8px 0; }
    /* カルーセル自身はピンチ禁止、横スクロールだけ許可 */
    .toc { height:44px; overflow-x:auto; overflow-y:hidden; white-space:nowrap;
      touch-action: pan-x; -webkit-overflow-scrolling: touch; }
    .toc::-webkit-scrollbar{ height:6px; }

    /* ページチップの見切れ対策 */
    .toc-list { display:flex; gap:8px; padding:0 8px; align-items:center; }

    /* ── 本文（ピンチ対象） ───────────────────────── */
    #content { max-width: 100%; margin: 0 auto; padding: 0 12px; }
    /* ズーム対象ラッパ */
    #zoom-area { transform-origin: 0 0; will-change: transform; touch-action: pan-y; }
    /* 横スクロールは常に禁止（縦だけ） */
    #zoom-area { overflow-x: hidden; }
    /* ページ画像 */
    .page-frame { position: relative; overflow:hidden;
      width: 100vw; max-width: 100vw;
      margin-left: calc(50% - 50vw); margin-right: calc(50% - 50vw);
      border:1px solid #e5e7eb; border-radius:12px; background:#fff; }
    .page-img { display:block; width:100%; height:auto; pointer-events:none; -webkit-user-drag:none; }

    /* ボタン色など */
    .btn-yellow { height:36px; padding:0 12px; border:1px solid #facc15; background:#fde047; color:#111; border-radius:9999px; }
  </style>
</head>
<body class="bg-white text-neutral-900">

  <!-- ── 固定カルーセル（ピンチ禁止 / 横スクロール可） ── -->
  <div id="toc-dock" class="toc-dock">
    <div class="max-w-full mx-auto px-3">
      <div class="flex items-center gap-2">
        <button id="car-prev" class="btn-yellow">≪</button>
        <button id="car-next" class="btn-yellow">≫</button>

        <nav id="toc" class="toc flex-1 min-w-0">
          <ul id="toc-list" class="toc-list"></ul>
        </nav>

        <button id="pg-prev" class="btn-yellow">←</button>
        <button id="pg-next" class="btn-yellow">→</button>
        <a id="btn-open" href="#" target="_blank" rel="noopener"
           class="h-9 px-3 rounded-full bg-neutral-100 text-neutral-900 border border-neutral-300 inline-flex items-center justify-center">Tab</a>
      </div>
    </div>
  </div>

  <!-- ── 本文（ピンチ対象） ── -->
  <main id="content">
    <div id="zoom-area"></div>
  </main>

  <script>
    /* ========= データ ========= */
    const BASE = "docs/";
    const groups = [
      { prefix: "1-", start: 1, end: 15 },
      { prefix: "2-", start: 1, end: 12 },
      { prefix: "3-", start: 1, end: 11 },
    ];
    const pad3 = (n) => String(n).padStart(3, "0");
    const files = groups.flatMap(g => Array.from({length:g.end-g.start+1},(_,i)=>`${g.prefix}${pad3(g.start+i)}.jpeg`));

    /* ========= 要素 ========= */
    const tocDock = document.getElementById('toc-dock');
    const tocEl   = document.getElementById('toc');
    const tocList = document.getElementById('toc-list');
    const zoomArea= document.getElementById('zoom-area');
    const content = document.getElementById('content');
    const btnOpen = document.getElementById('btn-open');
    const pgPrev  = document.getElementById('pg-prev');
    const pgNext  = document.getElementById('pg-next');
    const carPrev = document.getElementById('car-prev');
    const carNext = document.getElementById('car-next');

    /* ========= DOM生成 ========= */
    files.forEach((name, idx) => {
      // chip
      const li=document.createElement('li');
      const a=document.createElement('a');
      a.href=`#p-${name.replace(/\.[^.]+$/,'')}`;
      a.dataset.index=idx;
      a.textContent=name.replace('.jpeg','');
      a.className="inline-block px-3 py-1.5 border rounded-full select-none whitespace-nowrap border-neutral-300 bg-blue-50 text-blue-600";
      if(idx===0) a.classList.add("bg-linegreen","text-white","border-green-600");
      li.appendChild(a); tocList.appendChild(li);

      // section
      const sec=document.createElement('section');
      sec.id=`p-${name.replace(/\.[^.]+$/,'')}`;
      sec.className="py-4 border-b border-neutral-100";
      sec.innerHTML=`
        <figure class="page-frame">
          <img class="page-img" src="${BASE}${encodeURIComponent(name)}" alt="">
        </figure>`;
      zoomArea.appendChild(sec);
    });

    /* ========= 固定バー高さを本文に反映 ========= */
    function applyDockPad(){
      const h=tocDock.offsetHeight||60;
      content.style.paddingTop=(h+12)+'px';
    }
    new ResizeObserver(applyDockPad).observe(tocDock);
    window.addEventListener('resize',applyDockPad);
    applyDockPad();

    /* ========= 現在ページ検出 ========= */
    const sections=Array.from(document.querySelectorAll('main section'));
    const tocLinks=Array.from(document.querySelectorAll('#toc-list a'));
    let currentIndex=0;

    function setActive(i, ensureVisible=false){
      currentIndex=i;
      tocLinks.forEach((el,idx)=>{
        el.classList.toggle("bg-linegreen",idx===i);
        el.classList.toggle("text-white",idx===i);
        el.classList.toggle("border-green-600",idx===i);
        el.classList.toggle("bg-blue-50",idx!==i);
        el.classList.toggle("text-blue-600",idx!==i);
        el.classList.toggle("border-neutral-300",idx!==i);
      });
      const img=sections[i]?.querySelector('img');
      if(img) btnOpen.href=img.currentSrc||img.src;

      if(ensureVisible){
        const link=tocLinks[i], lr=link.getBoundingClientRect(), tr=tocEl.getBoundingClientRect();
        if(lr.left<tr.left) tocEl.scrollLeft+=lr.left-tr.left;
        else if(lr.right>tr.right) tocEl.scrollLeft+=lr.right-tr.right;
      }
    }
    function detectCurrentPage(){
      const baseline=tocDock.getBoundingClientRect().bottom;
      let idx=0;
      for(let i=0;i<sections.length;i++){
        const r=sections[i].getBoundingClientRect();
        const th=r.top+r.height*0.6;
        if(baseline>=th) idx=i+1;
      }
      const last=sections[sections.length-1].getBoundingClientRect();
      if(last.bottom<=window.innerHeight) idx=sections.length-1;
      if(idx>=sections.length) idx=sections.length-1;
      if(idx!==currentIndex) setActive(idx,false);
    }
    window.addEventListener('scroll',detectCurrentPage,{passive:true});
    window.addEventListener('resize',detectCurrentPage);
    window.addEventListener('load',detectCurrentPage);

    /* ========= ページ送り ========= */
    function scrollToSection(i, ensureVisible=false){
      const s=sections[i]; if(!s) return;
      window.scrollTo({ top:s.offsetTop, behavior:'auto' });
      requestAnimationFrame(()=>{ detectCurrentPage(); if(ensureVisible) setActive(i,true); });
    }
    pgPrev.onclick=()=>{ const next=Math.max(0,currentIndex-1); scrollToSection(next,true); };
    pgNext.onclick=()=>{ const next=Math.min(sections.length-1,currentIndex+1); scrollToSection(next,true); };

    /* ========= カルーセル左右（横スクロール可） ========= */
    function pageSize(){ const tr=tocEl.getBoundingClientRect(); return Math.max(200,tr.width*0.8); }
    let carTimer=null;
    function startCarScroll(dir){ if(carTimer) return; const step=Math.round(pageSize()*0.25); const tick=()=>tocEl.scrollBy({left:dir*step,behavior:'auto'}); tick(); carTimer=setInterval(tick,60); }
    function stopCarScroll(){ if(carTimer){ clearInterval(carTimer); carTimer=null; } }
    ['pointerup','pointercancel','pointerleave','touchend'].forEach(ev=>{ carPrev.addEventListener(ev,stopCarScroll); carNext.addEventListener(ev,stopCarScroll); });
    carPrev.addEventListener('pointerdown',e=>{ e.preventDefault(); startCarScroll(-1); });
    carNext.addEventListener('pointerdown',e=>{ e.preventDefault(); startCarScroll(+1); });
    tocLinks.forEach(a=>a.onclick=(e)=>{ e.preventDefault(); scrollToSection(Number(a.dataset.index), true); });

    /* ========= 本文ピンチズーム（最大2× / 安定描画） ========= */
    initGlobalZoom(); // ←呼び出し

    // 本文(#zoom-area)のピンチズーム: 最小1 / 最大2
// ・開始距離のデッドゾーン（誤検出防止）
// ・2本指→1本指の切替で基準を再確立（暴走防止）
// ・指が全て離れたら 1±ε は 1.0 にスナップして位置も原点へ
// ・拡大中はパン、等倍は縦スクロールのみ
    function initGlobalZoom() {
      const area = document.getElementById('zoom-area');
      if (!area) return;

      // ---------- 状態 ----------
      let scale = 1, tx = 0, ty = 0;            // 表示状態
      let mode = 'idle';                        // 'idle' | 'pinch' | 'pan' | 'scroll'
      let startScale = 1, startTx = 0, startTy = 0;
      let startDist = 0, hadDeadzone = false;   // デッドゾーン突破フラグ
      let startMid = { x: 0, y: 0 };
      const pts = new Map();                    // pointerId -> {x,y}

      const MIN_SCALE = 1;
      const MAX_SCALE = 2;
      const DEADZONE = 8;       // ピンチ開始距離の最小値(px)
      const SNAP_EPS = 0.02;    // 指離し後 1.0 へ吸着する閾値

      const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      const mid  = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) });
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const apply = () => {
        // 変な値が入らないよう最終防衛
        if (!Number.isFinite(scale)) scale = 1;
        if (!Number.isFinite(tx)) tx = 0;
        if (!Number.isFinite(ty)) ty = 0;
        area.style.transform = `translate(${Math.round(tx)}px, ${Math.round(ty)}px) scale(${scale})`;
      };

      // iOS ネイティブジェスチャ無効化（自前のみ）
      ['gesturestart','gesturechange','gestureend','dblclick','doubletap'].forEach(t => {
        area.addEventListener(t, e => e.preventDefault(), { passive:false });
      });

      // 初期は縦スクロール可（ブラウザに任せず自前で送る）
      area.style.touchAction = 'pan-y';

      function enterPinch() {
        const [p1, p2] = [...pts.values()];
        startDist = dist(p1, p2);
        hadDeadzone = (startDist > DEADZONE);
        startMid = mid(p1, p2);
        startScale = scale;
        startTx = tx; startTy = ty;
        mode = 'pinch';
        // ピンチ中はページスクロール止める
        area.style.touchAction = 'none';
        document.body.style.overflow = 'hidden';
      }

      function enterPanFrom(point) {
        startMid = { x: point.x, y: point.y };
        startTx = tx; startTy = ty;
        mode = (scale > 1) ? 'pan' : 'scroll';
        // pan/scroll 中は縦のユーザ操作を許す
        area.style.touchAction = (scale > 1) ? 'none' : 'pan-y';
        if (scale > 1) document.body.style.overflow = 'hidden';
      }

      function maybeSnapBack() {
        // 指がすべて離れたとき 1±EPS は 1 に吸着し、位置も原点へ戻す
        if (Math.abs(scale - 1) <= SNAP_EPS) {
          scale = 1; tx = 0; ty = 0;
          mode = 'idle';
          area.style.touchAction = 'pan-y';
          document.body.style.overflow = '';
          apply();
        } else {
          // 拡大維持時は pan モードへ
          mode = (scale > 1) ? 'pan' : 'idle';
          area.style.touchAction = (scale > 1) ? 'none' : 'pan-y';
          if (scale > 1) document.body.style.overflow = 'hidden';
          else document.body.style.overflow = '';
        }
      }

      // ---------- ポインタイベント ----------
      area.addEventListener('pointerdown', (e) => {
        area.setPointerCapture(e.pointerId);
        pts.set(e.pointerId, { x: e.clientX, y: e.clientY });
        if (pts.size === 2) enterPinch();
        else if (pts.size === 1) enterPanFrom({ x: e.clientX, y: e.clientY });
      });

      area.addEventListener('pointermove', (e) => {
        if (!pts.has(e.pointerId)) return;
        pts.set(e.pointerId, { x: e.clientX, y: e.clientY });

        if (mode === 'pinch' && pts.size === 2) {
          const [p1, p2] = [...pts.values()];
          const curDist = dist(p1, p2);

          // デッドゾーンを超えるまで拡大率を更新しない（暴走防止）
          if (!hadDeadzone) {
            if (curDist - startDist >= DEADZONE) hadDeadzone = true;
            else return; // まだ更新しない
          }

          let nextScale = startScale * (curDist / Math.max(1, startDist));
          nextScale = clamp(nextScale, MIN_SCALE, MAX_SCALE);

          // ピンチ中心固定
          const rect = area.getBoundingClientRect();
          const m = mid(p1, p2);
          const mx = m.x - rect.left, my = m.y - rect.top;

          const preX = (mx - startTx) / startScale;
          const preY = (my - startTy) / startScale;
          tx = mx - preX * nextScale;
          ty = my - preY * nextScale;

          scale = nextScale;
          apply();
          return;
        }

        // 1本指
        if (pts.size === 1) {
          const p = [...pts.values()][0];
          const dx = p.x - startMid.x;
          const dy = p.y - startMid.y;

          if (mode === 'pan' && scale > 1) {
            // 拡大中のパン
            tx = startTx + dx;
            ty = startTy + dy;
            apply();
          } else if (mode === 'scroll' && scale === 1) {
            // 等倍時の縦スクロールのみ（横はさせない）
            window.scrollBy(0, -dy);
            // 次回の差分基準を更新
            startMid = { x: p.x, y: p.y };
            startTx = tx; startTy = ty;
          }
        }
      });

      function onPointerEnd(e) {
        pts.delete(e.pointerId);

        if (pts.size === 2) {
          // 2本残ったら新しいピンチ基準へ切り替え
          enterPinch();
          return;
        }
        if (pts.size === 1) {
          // 1本に戻ったら pan/scroll へ基準を張り直す
          enterPanFrom([...pts.values()][0]);
          return;
        }
        // 0本：終了処理（スナップバック含む）
        document.body.style.overflow = '';
        maybeSnapBack();
      }
      area.addEventListener('pointerup', onPointerEnd);
      area.addEventListener('pointercancel', onPointerEnd);
      area.addEventListener('pointerleave', onPointerEnd);

      // ---------- ホイール/トラックパッド ----------
      // 拡大中のみパンに割り当て（既定スクロールは止める）
      area.addEventListener('wheel', (e) => {
        if (scale > 1) {
          e.preventDefault();
          tx -= e.deltaX;
          ty -= e.deltaY;
          apply();
        }
      }, { passive:false });

      // 初期適用
      apply();
    }
        /* 初期アクティブ */
        setActive(0,false);
  </script>
</body>
</html>