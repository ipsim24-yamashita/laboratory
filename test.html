<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
    />
    <title>GENESIS 解答ビューア</title>
    <style>
      :root {
        --dock-h: 0px;
        --line-green: #22c55e;
      }

      html,
      body {
        margin: 0;
        background: #fff;
        color: #111;
        font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif;
        overscroll-behavior-y: contain;
        overflow-x: hidden;
        touch-action: pan-y;
      }
      .wrap {
        width: 100%;
        margin: 0 auto;
        padding: 0 12px;
        box-sizing: border-box;
      }

      /* ===== カルーセル ===== */
      .toc-dock {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: #fff;
        border-bottom: 1px solid #eee;
        padding: 8px 0 env(safe-area-inset-top) 0;
      }
      .toc-bar {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }
      .btn {
        height: 34px;
        padding: 0 12px;
        border: 1px solid #ddd;
        border-radius: 999px;
        background: #f9fafb;
        color: #111;
        cursor: pointer;
        font-size: 14px;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .btn:disabled {
        opacity: 0.4;
        cursor: default;
      }

      .toc-container {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
      }
      .toc {
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        overscroll-behavior-x: contain;
      }
      .toc::-webkit-scrollbar {
        display: none;
      }
      .toc-list {
        display: flex;
        gap: 8px;
        padding: 0;
        margin: 0;
        list-style: none;
      }
      .toc-list a {
        display: inline-block;
        padding: 6px 12px;
        border: 1px solid #ddd;
        border-radius: 999px;
        background: #f0f6ff;
        color: #0366d6;
        text-decoration: none;
        user-select: none;
        transition: background-color 0.12s, color 0.12s, border-color 0.12s;
      }
      .toc-list a.active {
        background: var(--line-green);
        border-color: #16a34a;
        color: #fff;
      }
      .toolbar-right {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-shrink: 0;
      }

      /* ===== 本文 ===== */
      main {
        padding-top: calc(var(--dock-h) + 12px);
        padding-bottom: 48px;
      }
      section {
        padding: 18px 0;
        border-bottom: 1px solid #f0f0f0;
      }

      /* ===== 画像 ===== */
      .frame {
        position: relative;
        overflow: hidden;
        width: 100vw;
        max-width: 100vw;
        margin-left: calc(50% - 50vw);
        margin-right: calc(50% - 50vw);
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        background: #fff;
        touch-action: pan-y;
      }
      .frame img {
        display: block;
        width: 100%;
        height: auto;
        user-select: none;
        -webkit-user-drag: none;
        pointer-events: none;
        transform-origin: 0 0;
        will-change: transform;
      }

      /* ===== 虫眼鏡 ===== */
      .magnifier {
        position: absolute;
        display: none;
        pointer-events: none;
        /* ← サイズはJSで「表示エリアの2/3」に設定。固定のvw/vh指定はしない */
        border: 2px solid var(--line-green);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        background-repeat: no-repeat;
        background-origin: content-box;
      }
      .magnifier::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background: linear-gradient(
            to right,
            rgba(255, 255, 255, var(--gL, 0)),
            rgba(255, 255, 255, 0) 128px
          ),
          linear-gradient(
            to left,
            rgba(255, 255, 255, var(--gR, 0)),
            rgba(255, 255, 255, 0) 128px
          ),
          linear-gradient(
            to bottom,
            rgba(255, 255, 255, var(--gT, 0)),
            rgba(255, 255, 255, 0) 128px
          ),
          linear-gradient(
            to top,
            rgba(255, 255, 255, var(--gB, 0)),
            rgba(255, 255, 255, 0) 128px
          );
        mix-blend-mode: multiply;
      }
      /* 追加：虫眼鏡を画面中央固定にする */
      .magnifier {
        position: fixed !important;
      } /* 既存はabsoluteだが虫眼鏡のみfixed化 */
    </style>
  </head>
  <body>
    <div class="toc-dock" id="toc-dock">
      <div class="wrap">
        <div class="toc-bar">
          <button class="btn" id="car-prev">≪</button>
          <button class="btn" id="car-next">≫</button>
          <div class="toc-container">
            <nav class="toc" id="toc">
              <ul class="toc-list" id="toc-list"></ul>
            </nav>
          </div>
          <div class="toolbar-right">
            <button class="btn" id="pg-prev">←</button>
            <button class="btn" id="pg-next">→</button>
            <button class="btn" id="btn-mag">虫眼鏡</button>
            <button class="btn" id="btn-zoom">2倍</button>
            <a class="btn" id="btn-open" href="#" target="_blank" rel="noopener"
              >原寸</a
            >
          </div>
        </div>
      </div>
    </div>

    <main class="wrap" id="content"></main>

    <script>
      /* ========= 画像リスト ========= */
      const BASE = "docs/";
      const groups = [
        { prefix: "1-", start: 1, end: 15 },
        { prefix: "2-", start: 1, end: 12 },
        { prefix: "3-", start: 1, end: 11 },
      ];
      const pad3 = (n) => String(n).padStart(3, "0");
      const files = groups.flatMap((g) =>
        Array.from(
          { length: g.end - g.start + 1 },
          (_, i) => `${g.prefix}${pad3(g.start + i)}.jpeg`
        )
      );

      /* ========= 要素 ========= */
      const tocEl = document.getElementById("toc");
      const tocList = document.getElementById("toc-list");
      const content = document.getElementById("content");
      const btnOpen = document.getElementById("btn-open");
      const btnZoom = document.getElementById("btn-zoom");
      const btnMag = document.getElementById("btn-mag");
      const pgPrev = document.getElementById("pg-prev");
      const pgNext = document.getElementById("pg-next");
      const carPrev = document.getElementById("car-prev");
      const carNext = document.getElementById("car-next");
      const dockEl = document.getElementById("toc-dock");

      /* ========= DOM生成 ========= */
      files.forEach((name, idx) => {
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = `#p-${name.replace(/\.[^.]+$/, "")}`;
        a.dataset.index = idx;
        a.textContent = name.replace(".jpeg", "");
        if (idx === 0) a.classList.add("active");
        li.appendChild(a);
        tocList.appendChild(li);

        const sec = document.createElement("section");
        sec.dataset.index = idx;
        sec.id = `p-${name.replace(/\.[^.]+$/, "")}`;
        sec.innerHTML = `
    <figure class="frame">
      <img src="${BASE}${encodeURIComponent(name)}" alt="">
      <div class="magnifier"></div>
    </figure>`;
        content.appendChild(sec);
      });

      /* ========= 高さ更新 ========= */
      function applyDockH() {
        document.documentElement.style.setProperty(
          "--dock-h",
          (dockEl?.offsetHeight || 0) + "px"
        );
      }
      new ResizeObserver(applyDockH).observe(dockEl);
      window.addEventListener("resize", applyDockH);
      applyDockH();

      const sections = Array.from(document.querySelectorAll("main section"));
      const tocLinks = Array.from(document.querySelectorAll("#toc-list a"));
      let currentIndex = 0;

      /* ========= 現在地判定 ========= */
      function detectCurrentPage() {
        const baseline = dockEl.getBoundingClientRect().bottom;
        let idx = 0;
        for (let i = 0; i < sections.length; i++) {
          const r = sections[i].getBoundingClientRect();
          const th = r.top + r.height * 0.6; // 60%
          if (baseline >= th) idx = i + 1;
        }
        const last = sections[sections.length - 1].getBoundingClientRect();
        if (last.bottom <= window.innerHeight) idx = sections.length - 1;
        if (idx >= sections.length) idx = sections.length - 1;
        if (idx !== currentIndex) setActive(idx);
      }
      function setActive(i) {
        currentIndex = i;
        tocLinks.forEach((el, idx) => el.classList.toggle("active", idx === i));
        const img = sections[i]?.querySelector("img");
        if (img) btnOpen.href = img.currentSrc || img.src;
      }
      window.addEventListener("scroll", detectCurrentPage, { passive: true });
      window.addEventListener("resize", detectCurrentPage);
      window.addEventListener("load", detectCurrentPage);

      /* ========= ページ移動 ========= */
      function scrollToSection(i) {
        const s = sections[i];
        if (!s) return;
        window.scrollTo({ top: s.offsetTop, behavior: "auto" });
        requestAnimationFrame(detectCurrentPage);
      }

      /* ======== カルーセル（←/→ 端固定、≪/≫そのまま） ======== */
      /* ======== カルーセル（←/→ 端固定、≪/≫そのまま） ======== */
      /* ======== カルーセル（←/→ 端固定、≪/≫そのまま） ======== */
      /* ======== カルーセル（←/→ 端固定、≪/≫そのまま） ======== */
      /* ======== カルーセル（←/→ 端固定、≪/≫そのまま） ======== */
      function pinLinkToEdge(link, side) {
        if (!link) return;
        if (side === "left") {
          tocEl.scrollLeft = link.offsetLeft;
        } else {
          tocEl.scrollLeft =
            link.offsetLeft - (tocEl.clientWidth - link.offsetWidth);
        }
      }
      function movePrevWithPin() {
        if (currentIndex <= 0) {
          pinLinkToEdge(tocLinks[currentIndex], "left");
          return;
        }
        const next = currentIndex - 1;
        scrollToSection(next);
        requestAnimationFrame(() => pinLinkToEdge(tocLinks[next], "left"));
      }
      function moveNextWithPin() {
        if (currentIndex >= sections.length - 1) {
          pinLinkToEdge(tocLinks[currentIndex], "right");
          return;
        }
        const next = currentIndex + 1;
        scrollToSection(next);
        requestAnimationFrame(() => pinLinkToEdge(tocLinks[next], "right"));
      }
      pgPrev.onclick = movePrevWithPin;
      pgNext.onclick = moveNextWithPin;
      tocLinks.forEach(
        (a) =>
          (a.onclick = (e) => {
            e.preventDefault();
            scrollToSection(Number(a.dataset.index));
          })
      );

      function pageSize() {
        return Math.max(200, tocEl.clientWidth * 0.8);
      }
      carPrev.onclick = () =>
        tocEl.scrollBy({ left: -pageSize(), behavior: "auto" });
      carNext.onclick = () =>
        tocEl.scrollBy({ left: pageSize(), behavior: "auto" });

      /* ========= 虫眼鏡：中央固定 / 5×5マッピング / 画面の2/3 / スクロール制御 ========= */
      /* ========= 虫眼鏡：中央固定 / 5×5マッピング / 画面の2/3 / スクロール制御 ========= */
      /* ========= 虫眼鏡：中央固定 / 5×5マッピング / 画面の2/3 / スクロール制御 ========= */
      /* ========= 虫眼鏡：中央固定 / 5×5マッピング / 画面の2/3 / スクロール制御 ========= */
      /* ========= 虫眼鏡：中央固定 / 5×5マッピング / 画面の2/3 / スクロール制御 ========= */
      /* ========= 虫眼鏡：中央固定 / 5×5マッピング / 画面の2/3 / スクロール制御（上段無反応修正） ========= */
      let zoomedFrame = null,
        magFrame = null;

      /* 表示エリア（ドック下〜下端） */
      function visibleAreaBounds() {
        return {
          left: 0,
          right: window.innerWidth,
          top: document.getElementById("toc-dock").getBoundingClientRect()
            .bottom,
          bottom: window.innerHeight,
        };
      }

      /* スクロール禁止/許可 */
      let _wheelBlocker = null,
        _touchBlocker = null;
      function lockScroll() {
        if (_wheelBlocker || _touchBlocker) return;
        document.body.style.overflow = "hidden";
        document.body.style.touchAction = "none";
        _wheelBlocker = (e) => {
          e.preventDefault();
        };
        _touchBlocker = (e) => {
          e.preventDefault();
        };
        window.addEventListener("wheel", _wheelBlocker, {
          passive: false,
          capture: true,
        });
        window.addEventListener("touchmove", _touchBlocker, {
          passive: false,
          capture: true,
        });
      }
      function unlockScroll() {
        document.body.style.overflow = "";
        document.body.style.touchAction = "";
        if (_wheelBlocker) {
          window.removeEventListener("wheel", _wheelBlocker, { capture: true });
          _wheelBlocker = null;
        }
        if (_touchBlocker) {
          window.removeEventListener("touchmove", _touchBlocker, {
            capture: true,
          });
          _touchBlocker = null;
        }
      }

      /* === サイズ：表示エリアの 2/3 === */
      function sizeMagnifierTwoThirds(mag) {
        const vb = visibleAreaBounds();
        const vw = vb.right - vb.left,
          vh = vb.bottom - vb.top;
        mag.style.width = Math.round((vw * 2) / 3) + "px";
        mag.style.height = Math.round((vh * 2) / 3) + "px";
      }

      /* === 画面中央に固定 === */
      function centerMagnifier(mag) {
        const vb = visibleAreaBounds();
        const w = mag.offsetWidth,
          h = mag.offsetHeight;
        const left = Math.round((vb.left + vb.right - w) / 2);
        const top = Math.round((vb.top + vb.bottom - h) / 2);
        mag.style.left = left + "px";
        mag.style.top = top + "px";

        const th = 128;
        const distL = left - vb.left;
        const distR = vb.right - w - left;
        const distT = top - vb.top;
        const distB = vb.bottom - h - top;
      }

      /* === pointer座標を表示エリア内にクランプして 5×5 セルを決定（上段無反応対策） === */
      function pickCell5x5(clientX, clientY) {
        const vb = visibleAreaBounds();
        // まず vb 内にクランプ（ドック上に触れても row=0 に入る）
        const x = Math.max(vb.left, Math.min(vb.right - 1, clientX));
        const y = Math.max(vb.top, Math.min(vb.bottom - 1, clientY));
        const vw = vb.right - vb.left,
          vh = vb.bottom - vb.top;
        const nx = (x - vb.left) / vw;
        const ny = (y - vb.top) / vh;
        const col = Math.min(4, Math.max(0, Math.floor(nx * 5)));
        const row = Math.min(4, Math.max(0, Math.floor(ny * 5)));
        return [col, row];
      }

      /* === 指定セル（5×5）に対応する“元画像側セル”を虫眼鏡へ（縦横比維持） === */
      function updateMagnifierForCell(frame, mag, col, row) {
        const img = frame.querySelector("img");
        const ir = img.getBoundingClientRect(); // 表示中の画像サイズ（比率維持）
        const mr = mag.getBoundingClientRect(); // 中央固定の虫眼鏡

        const w = mag.clientWidth,
          h = mag.clientHeight;

        // 画像側 5×5 の対象領域（表示座標系）
        const srcW = ir.width / 5;
        const srcH = ir.height / 5;
        const srcX = col * srcW;
        const srcY = row * srcH;

        // 歪みなしでフィット（余白最小：contain）
        const scale = Math.min(w / srcW, h / srcH);

        // 背景サイズ＝画像表示サイズ × scale（縦横比そのまま）
        const bgW = ir.width * scale;
        const bgH = ir.height * scale;
        mag.style.backgroundImage = `url("${img.currentSrc || img.src}")`;
        mag.style.backgroundSize = `${Math.round(bgW)}px ${Math.round(bgH)}px`;

        // 画像左上→虫眼鏡左上の相対を scale し、選択セルの中心を虫眼鏡中心へ
        const dx = (ir.left - mr.left) * scale;
        const dy = (ir.top - mr.top) * scale;
        const srcCX = srcX + srcW / 2;
        const srcCY = srcY + srcH / 2;
        const bgX = -(dx + srcCX * scale) + w / 2;
        const bgY = -(dy + srcCY * scale) + h / 2;

        mag.style.backgroundPosition = `${Math.round(bgX)}px ${Math.round(
          bgY
        )}px`;

        // 記録
        mag.dataset.col = String(col);
        mag.dataset.row = String(row);
        mag.dataset.scale = String(scale);
      }

      /* === ON / OFF（中央固定 / 5×5 / スクロールロック / 取りこぼし対策） === */
      function enterMagnifier(frame) {
        if (zoomedFrame) exitZoom(zoomedFrame); // 2倍とは排反

        const mag = frame.querySelector(".magnifier");
        sizeMagnifierTwoThirds(mag); // 画面の2/3
        mag.style.display = "block";
        magFrame = frame;
        btnMag.textContent = "オフ";

        // 中央固定
        centerMagnifier(mag);

        // 初期セル：左から2番目 × 上から3番目（col=1,row=2）ご指定どおり
        updateMagnifierForCell(frame, mag, 1, 2);

        // スクロール禁止
        lockScroll();

        // 取りこぼしを避けるため、capture で window に張る
        const onMove = (e) => {
          const t = (e.touches && e.touches[0]) || e;
          const [c, r] = pickCell5x5(t.clientX, t.clientY);
          if (String(c) === mag.dataset.col && String(r) === mag.dataset.row)
            return;
          updateMagnifierForCell(frame, mag, c, r);
        };
        window.addEventListener("pointermove", onMove, {
          passive: true,
          capture: true,
        });
        window.addEventListener("touchmove", onMove, {
          passive: true,
          capture: true,
        });
        frame._magMoveHandler = onMove;

        // リサイズ：サイズ再計算→中央再固定→同セル再描画
        const onResize = () => {
          if (mag.style.display !== "block") return;
          sizeMagnifierTwoThirds(mag);
          centerMagnifier(mag);
          const c = Number(mag.dataset.col || 1);
          const r = Number(mag.dataset.row || 2);
          updateMagnifierForCell(frame, mag, c, r);
        };
        window.addEventListener("resize", onResize, { passive: true });
        frame._magResizeHandler = onResize;
      }

      function exitMagnifier(frame) {
        const mag = frame.querySelector(".magnifier");
        mag.style.display = "none";

        if (frame._magMoveHandler) {
          window.removeEventListener("pointermove", frame._magMoveHandler, {
            capture: true,
          });
          window.removeEventListener("touchmove", frame._magMoveHandler, {
            capture: true,
          });
          frame._magMoveHandler = null;
        }
        if (frame._magResizeHandler) {
          window.removeEventListener("resize", frame._magResizeHandler);
          frame._magResizeHandler = null;
        }
        unlockScroll();
        magFrame = null;
        btnMag.textContent = "虫眼鏡";
      }

      /* 既存のボタンハンドラはそのまま利用 */
      btnMag.onclick = () => {
        const f = sections[currentIndex].querySelector(".frame");
        if (magFrame && magFrame === f) exitMagnifier(f);
        else {
          if (magFrame && magFrame !== f) exitMagnifier(magFrame);
          enterMagnifier(f);
        }
      };

      /* ========= 2倍ズーム（既存そのまま／虫眼鏡と排反） ========= */
      /* ========= 2倍ズーム（既存そのまま／虫眼鏡と排反） ========= */
      /* ========= 2倍ズーム（既存そのまま／虫眼鏡と排反） ========= */
      /* ========= 2倍ズーム（既存そのまま／虫眼鏡と排反） ========= */
      /* ========= 2倍ズーム（既存そのまま／虫眼鏡と排反） ========= */
      function enterZoom(frame) {
        if (magFrame) exitMagnifier(magFrame);
        const img = frame.querySelector("img");
        let sx,
          sy,
          tx = 0,
          ty = 0;
        img.style.transform = `translate(0,0) scale(2)`;
        frame.style.touchAction = "none";
        frame.onpointerdown = (e) => {
          sx = e.clientX;
          sy = e.clientY;
          frame.setPointerCapture(e.pointerId);
        };
        frame.onpointermove = (e) => {
          if (sx == null) return;
          const dx = e.clientX - sx,
            dy = e.clientY - sy;
          tx += dx;
          ty += dy;
          const maxX = (img.clientWidth * 2 - frame.clientWidth) / 2;
          const maxY = (img.clientHeight * 2 - frame.clientHeight) / 2;
          tx = Math.max(-maxX, Math.min(maxX, tx));
          ty = Math.max(-maxY, Math.min(maxY, ty));
          img.style.transform = `translate(${tx}px,${ty}px) scale(2)`;
          sx = e.clientX;
          sy = e.clientY;
        };
        frame.onpointerup = (e) => {
          sx = null;
          try {
            frame.releasePointerCapture(e.pointerId);
          } catch {}
        };
        zoomedFrame = frame;
        btnZoom.textContent = "1倍";
      }
      function exitZoom(frame) {
        const img = frame.querySelector("img");
        img.style.transform = "scale(1)";
        frame.style.touchAction = "pan-y";
        frame.onpointerdown = frame.onpointermove = frame.onpointerup = null;
        zoomedFrame = null;
        btnZoom.textContent = "2倍";
      }
      btnZoom.onclick = () => {
        const f = sections[currentIndex].querySelector(".frame");
        if (zoomedFrame && zoomedFrame !== f) exitZoom(zoomedFrame);
        if (btnZoom.textContent === "2倍") enterZoom(f);
        else exitZoom(f);
      };
    </script>
  </body>
</html>
