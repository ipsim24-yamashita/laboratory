<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
    />
    <title>GENESIS 解答ビューア</title>
    <style>
      :root { --dock-h: 0px; --line-green: #22c55e; }

      html, body {
        margin: 0; background: #fff; color: #111;
        font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif;
        overscroll-behavior-y: contain; overflow-x: hidden; touch-action: pan-y;
      }
      .wrap { width: 100%; margin: 0 auto; padding: 0 12px; box-sizing: border-box; }

      /* ===== カルーセル ===== */
      .toc-dock {
        position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
        background: #fff; border-bottom: 1px solid #eee;
        padding: 8px 0 env(safe-area-inset-top) 0;
      }
      .toc-bar { display: flex; align-items: center; gap: 10px; width: 100%; box-sizing: border-box; overflow: hidden; }
      .btn {
        height: 34px; padding: 0 12px; border: 1px solid #ddd; border-radius: 999px;
        background: #f9fafb; color: #111; cursor: pointer; font-size: 14px; text-decoration: none;
        display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0;
        -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      }
      .btn:disabled { opacity: .4; cursor: default; }

      .toc-container { flex: 1 1 auto; min-width: 0; overflow: hidden; }
      .toc { overflow-x: auto; overflow-y: hidden; white-space: nowrap; -webkit-overflow-scrolling: touch; scrollbar-width: none; overscroll-behavior-x: contain; }
      .toc::-webkit-scrollbar { display: none; }
      .toc-list { display: flex; gap: 8px; padding: 0; margin: 0; list-style: none; }
      .toc-list a {
        display: inline-block; padding: 6px 12px; border: 1px solid #ddd; border-radius: 999px;
        background: #f0f6ff; color: #0366d6; text-decoration: none; user-select: none;
        transition: background-color .12s, color .12s, border-color .12s;
      }
      .toc-list a.active { background: var(--line-green); border-color: #16a34a; color: #fff; }
      .toolbar-right { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }

      /* ===== 本文 ===== */
      main { padding-top: calc(var(--dock-h) + 12px); padding-bottom: 48px; }
      section { padding: 18px 0; border-bottom: 1px solid #f0f0f0; }

      /* ===== 画像 ===== */
      .frame {
        position: relative; overflow: hidden;
        width: 100vw; max-width: 100vw;
        margin-left: calc(50% - 50vw); margin-right: calc(50% - 50vw);
        border: 1px solid #e5e7eb; border-radius: 12px; background: #fff;
        touch-action: pan-y;
      }
      .frame img {
        display: block; width: 100%; height: auto;
        user-select: none; -webkit-user-drag: none; pointer-events: none;
        transform-origin: 0 0; will-change: transform;
      }

      /* ===== 虫眼鏡（中央固定 + 8方向ボタン） ===== */
      .magnifier {
        position: fixed !important;
        display: none;
        border: 2px solid var(--line-green);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 6px rgba(0,0,0,.25);
        background: #fff;
        /* 長押しテキスト選択や呼び出しメニューを抑止 */
        -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      }
      .magnifier img {
        position: absolute; left: 0; top: 0;
        pointer-events: none; user-select: none; -webkit-user-drag: none;
      }

      .mag-controls {
        position: absolute; inset: 0;
        pointer-events: none; /* ボタン以外は反応しない */
        -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      }
      .mag-btn {
        position: absolute;
        width: 44px; height: 44px; border-radius: 999px;
        background: rgba(17,17,17,.85); border: none;
        display: grid; place-items: center;
        pointer-events: auto; touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      }
      .mag-btn:active { transform: scale(.98); }

      /* 8方向の配置 */
      .mag-btn.n  { top: 8px; left: 50%; transform: translate(-50%,0); }
      .mag-btn.s  { bottom: 8px; left: 50%; transform: translate(-50%,0); }
      .mag-btn.w  { left: 8px; top: 50%; transform: translate(0,-50%); }
      .mag-btn.e  { right: 8px; top: 50%; transform: translate(0,-50%); }
      .mag-btn.nw { top: 8px; left: 8px; }
      .mag-btn.ne { top: 8px; right: 8px; }
      .mag-btn.sw { bottom: 8px; left: 8px; }
      .mag-btn.se { bottom: 8px; right: 8px; }

      /* 矢印SVGのサイズ調整 */
      .mag-btn svg { width: 22px; height: 22px; fill: #fff; }
    </style>
  </head>
  <body>
    <div class="toc-dock" id="toc-dock">
      <div class="wrap">
        <div class="toc-bar">
          <button class="btn" id="car-prev">≪</button>
          <button class="btn" id="car-next">≫</button>
          <div class="toc-container">
            <nav class="toc" id="toc">
              <ul class="toc-list" id="toc-list"></ul>
            </nav>
          </div>
          <div class="toolbar-right">
            <button class="btn" id="pg-prev">←</button>
            <button class="btn" id="pg-next">→</button>
            <button class="btn" id="btn-mag">虫眼鏡</button>
            <button class="btn" id="btn-zoom">2倍</button>
            <a class="btn" id="btn-open" href="#" target="_blank" rel="noopener">原寸</a>
          </div>
        </div>
      </div>
    </div>

    <main class="wrap" id="content"></main>

    <script>
      /* ========= 画像リスト ========= */
      const BASE = "docs/";
      const groups = [
        { prefix: "1-", start: 1, end: 15 },
        { prefix: "2-", start: 1, end: 12 },
        { prefix: "3-", start: 1, end: 11 },
      ];
      const pad3 = (n) => String(n).padStart(3, "0");
      const files = groups.flatMap((g) =>
        Array.from({ length: g.end - g.start + 1 }, (_, i) => `${g.prefix}${pad3(g.start + i)}.jpeg`)
      );

      /* ========= 要素 ========= */
      const tocEl = document.getElementById("toc");
      const tocList = document.getElementById("toc-list");
      const content = document.getElementById("content");
      const btnOpen = document.getElementById("btn-open");
      const btnZoom = document.getElementById("btn-zoom");
      const btnMag  = document.getElementById("btn-mag");
      const pgPrev = document.getElementById("pg-prev");
      const pgNext = document.getElementById("pg-next");
      const carPrev = document.getElementById("car-prev");
      const carNext = document.getElementById("car-next");
      const dockEl  = document.getElementById("toc-dock");

      /* ========= DOM生成 ========= */
      files.forEach((name, idx) => {
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = `#p-${name.replace(/\.[^.]+$/, "")}`;
        a.dataset.index = idx;
        a.textContent = name.replace(".jpeg", "");
        if (idx === 0) a.classList.add("active");
        li.appendChild(a); tocList.appendChild(li);

        const sec = document.createElement("section");
        sec.dataset.index = idx;
        sec.id = `p-${name.replace(/\.[^.]+$/, "")}`;
        sec.innerHTML = `
          <figure class="frame">
            <img src="${BASE}${encodeURIComponent(name)}" alt="">
            <div class="magnifier"></div>
          </figure>`;
        content.appendChild(sec);
      });

      /* ========= 高さ更新 ========= */
      function applyDockH() {
        document.documentElement.style.setProperty("--dock-h", (dockEl?.offsetHeight || 0) + "px");
      }
      new ResizeObserver(applyDockH).observe(dockEl);
      window.addEventListener("resize", applyDockH);
      applyDockH();

      const sections = Array.from(document.querySelectorAll("main section"));
      const tocLinks = Array.from(document.querySelectorAll("#toc-list a"));
      let currentIndex = 0;

      /* ========= 現在地判定 ========= */
      function detectCurrentPage() {
        const baseline = dockEl.getBoundingClientRect().bottom;
        let idx = 0;
        for (let i = 0; i < sections.length; i++) {
          const r = sections[i].getBoundingClientRect();
          const th = r.top + r.height * 0.6; // 60%
          if (baseline >= th) idx = i + 1;
        }
        const last = sections[sections.length - 1].getBoundingClientRect();
        if (last.bottom <= window.innerHeight) idx = sections.length - 1;
        if (idx >= sections.length) idx = sections.length - 1;
        if (idx !== currentIndex) setActive(idx);
      }
      function setActive(i) {
        currentIndex = i;
        tocLinks.forEach((el, idx) => el.classList.toggle("active", idx === i));
        const img = sections[i]?.querySelector("img");
        if (img) btnOpen.href = img.currentSrc || img.src;

        // 虫眼鏡がONなら、対象画像を「現在ページ」に切替（位置は中央にリセット）
        if (magFrame) {
          magFrame = sections[i].querySelector(".frame");
          const mag = document.querySelector(".magnifier");
          // レンズのサイズ・位置は維持（固定）
          const ir = magFrame.querySelector("img").getBoundingClientRect();
          _magState = { cx: ir.width / 2, cy: ir.height / 2 };
          renderMagnifier(magFrame, mag, _magState);
        }
      }
      window.addEventListener("scroll", detectCurrentPage, { passive: true });
      window.addEventListener("resize", detectCurrentPage);
      window.addEventListener("load", detectCurrentPage);

      /* ========= ページ移動 ========= */
      function scrollToSection(i) {
        const s = sections[i]; if (!s) return;
        window.scrollTo({ top: s.offsetTop, behavior: "auto" });
        requestAnimationFrame(detectCurrentPage);
      }

      /* ======== カルーセル（←/→ 端固定、≪/≫はそのままスクロール） ======== */
      function pinLinkToEdge(link, side) {
        if (!link) return;
        if (side === "left") tocEl.scrollLeft = link.offsetLeft;
        else tocEl.scrollLeft = link.offsetLeft - (tocEl.clientWidth - link.offsetWidth);
      }
      function movePrevWithPin() {
        if (currentIndex <= 0) { pinLinkToEdge(tocLinks[currentIndex], "left"); return; }
        const next = currentIndex - 1;
        scrollToSection(next);
        requestAnimationFrame(() => pinLinkToEdge(tocLinks[next], "left"));
      }
      function moveNextWithPin() {
        if (currentIndex >= sections.length - 1) { pinLinkToEdge(tocLinks[currentIndex], "right"); return; }
        const next = currentIndex + 1;
        scrollToSection(next);
        requestAnimationFrame(() => pinLinkToEdge(tocLinks[next], "right"));
      }
      pgPrev.onclick = movePrevWithPin;
      pgNext.onclick = moveNextWithPin;
      tocLinks.forEach(a => a.onclick = (e) => { e.preventDefault(); scrollToSection(Number(a.dataset.index)); });

      function pageSize() { return Math.max(200, tocEl.clientWidth * 0.8); }
      carPrev.onclick = () => tocEl.scrollBy({ left: -pageSize(), behavior: "auto" });
      carNext.onclick = () => tocEl.scrollBy({ left:  pageSize(), behavior: "auto" });

      /* ========= 虫眼鏡（中央固定 2倍 / 8方向ボタンでシームレス走査） ========= */
      let zoomedFrame = null, magFrame = null, _magState = null;

      function visibleAreaBounds() {
        return {
          left: 0, right: window.innerWidth,
          top:  document.getElementById("toc-dock").getBoundingClientRect().bottom,
          bottom: window.innerHeight,
        };
      }
      function lockScroll() {
        document.body.style.overflow = "hidden";
        document.body.style.touchAction = "none";
      }
      function unlockScroll() {
        document.body.style.overflow = "";
        document.body.style.touchAction = "";
      }
      function sizeMagnifierTwoThirds(mag) {
        const vb = visibleAreaBounds();
        mag.style.width  = Math.round(((vb.right - vb.left) * 2) / 3) + "px";
        mag.style.height = Math.round(((vb.bottom - vb.top) * 2) / 3) + "px";
      }
      function centerMagnifier(mag) {
        const vb = visibleAreaBounds();
        const w = mag.offsetWidth, h = mag.offsetHeight;
        mag.style.left = Math.round((vb.left + vb.right - w) / 2) + "px";
        mag.style.top  = Math.round((vb.top  + vb.bottom - h) / 2) + "px";
      }

      // レンズ描画：cx,cy は「表示画像座標系」の中心点（操作範囲＝元画像）
      function renderMagnifier(frame, mag, state) {
        const img = frame.querySelector("img");
        const ir = img.getBoundingClientRect(); // 表示上の画像サイズ
        const w = mag.clientWidth, h = mag.clientHeight;

        const s = 2; // 2倍固定
        let mi = mag.querySelector("img");
        if (!mi) {
          mi = document.createElement("img");
          mi.alt = ""; mi.draggable = false;
          mag.appendChild(mi);
        }
        const src = img.currentSrc || img.src;
        if (mi.src !== src) mi.src = src;

        const imgW = ir.width  * s;
        const imgH = ir.height * s;
        mi.style.width  = imgW + "px";
        mi.style.height = imgH + "px";

        // 画像左上をレンズ内に配置する平行移動量（レンズ中心＝state(cx,cy)）
        let offX = Math.round(w/2 - state.cx * s);
        let offY = Math.round(h/2 - state.cy * s);

        // 端クランプ（四隅ピタ表示）
        const minX = w - imgW, maxX = 0;
        const minY = h - imgH, maxY = 0;
        offX = Math.max(minX, Math.min(maxX, offX));
        offY = Math.max(minY, Math.min(maxY, offY));

        mi.style.transform = `translate(${offX}px, ${offY}px)`;
      }

      // SVGアイコン（文字選択を回避）
      const ARROWS = {
        n:  '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 4l-6 6h4v8h4V10h4z"/></svg>',
        s:  '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 20l6-6h-4V6h-4v8H6z"/></svg>',
        w:  '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 12l6 6v-4h8v-4H10V6z"/></svg>',
        e:  '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M20 12l-6-6v4H6v4h8v4z"/></svg>',
        nw: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 9h6V5l8 8-2.8 2.8L11 10.6V17H5z"/></svg>',
        ne: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M19 9h-6V5L5 13l2.8 2.8L13 10.6V17h6z"/></svg>',
        sw: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M5 15h6v4l8-8-2.8-2.8L11 13.4V7H5z"/></svg>',
        se: '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M19 15h-6v4L5 11l2.8-2.8L13 13.4V7h6z"/></svg>',
      };

      function ensureMagControls(mag, onStep) {
        if (mag.querySelector(".mag-controls")) return;
        const box = document.createElement("div");
        box.className = "mag-controls";
        box.innerHTML = `
          <button class="mag-btn n"  aria-label="上">${ARROWS.n}</button>
          <button class="mag-btn s"  aria-label="下">${ARROWS.s}</button>
          <button class="mag-btn w"  aria-label="左">${ARROWS.w}</button>
          <button class="mag-btn e"  aria-label="右">${ARROWS.e}</button>
          <button class="mag-btn nw" aria-label="左上">${ARROWS.nw}</button>
          <button class="mag-btn ne" aria-label="右上">${ARROWS.ne}</button>
          <button class="mag-btn sw" aria-label="左下">${ARROWS.sw}</button>
          <button class="mag-btn se" aria-label="右下">${ARROWS.se}</button>
        `;
        mag.appendChild(box);

        // 長押し連続移動（50ms刻み）。押下中は一切の選択・コールアウトを抑止。
        const map = {
          n:[0,-1], s:[0,1], w:[-1,0], e:[1,0],
          nw:[-1,-1], ne:[1,-1], sw:[-1,1], se:[1,1],
        };
        box.querySelectorAll(".mag-btn").forEach(btn => {
          const dir = Array.from(btn.classList).find(c => map[c]);
          const [dx, dy] = map[dir];
          let t, running = false;

          const stepOnce = () => onStep(dx, dy);
          const start = (e) => {
            e.preventDefault();
            if (running) return; running = true;
            // iOSの選択/メニュー抑止（保険）
            document.body.style.webkitUserSelect = 'none';
            document.body.style.userSelect = 'none';
            stepOnce();
            t = setInterval(stepOnce, 50);
          };
          const stop = () => {
            running = false; clearInterval(t);
            document.body.style.webkitUserSelect = '';
            document.body.style.userSelect = '';
          };

          btn.addEventListener("pointerdown", start);
          btn.addEventListener("pointerup", stop);
          btn.addEventListener("pointercancel", stop);
          btn.addEventListener("pointerleave", stop);
        });
      }

      function enterMagnifier(frame) {
        if (zoomedFrame) exitZoom(zoomedFrame); // 2倍とは排反
        const mag = document.querySelector(".magnifier") || (() => {
          const m = frame.querySelector(".magnifier");
          return m;
        })();

        mag.style.display = "block";
        sizeMagnifierTwoThirds(mag);
        centerMagnifier(mag);
        magFrame = sections[currentIndex].querySelector(".frame");
        btnMag.textContent = "オフ";
        lockScroll();

        // 現在ページの画像中央から開始
        const ir = magFrame.querySelector("img").getBoundingClientRect();
        _magState = { cx: ir.width / 2, cy: ir.height / 2 };

        const stepBase = Math.max(12, Math.round(Math.min(ir.width, ir.height) / 18)); // 端末差を吸収
        const onStep = (dx, dy) => {
          // 最新の表示サイズを毎回取得（回転・リフロー対応）
          const irNow = magFrame.querySelector("img").getBoundingClientRect();
          const speed = stepBase;
          _magState.cx += dx * speed;
          _magState.cy += dy * speed;
          // 操作範囲＝元画像（表示座標）にクランプ
          _magState.cx = Math.max(0, Math.min(irNow.width,  _magState.cx));
          _magState.cy = Math.max(0, Math.min(irNow.height, _magState.cy));
          renderMagnifier(magFrame, mag, _magState);
        };

        // 初回描画
        renderMagnifier(magFrame, mag, _magState);
        // コントロール（初回のみ生成）
        ensureMagControls(mag, onStep);

        // 画面回転・リサイズ時：レンズは中央維持、画像比に合わせて位置補正
        const onResize = () => {
          sizeMagnifierTwoThirds(mag);
          centerMagnifier(mag);
          const ir2 = magFrame.querySelector("img").getBoundingClientRect();
          // 端まで表示できるよう毎回クランプ
          _magState.cx = Math.max(0, Math.min(ir2.width,  _magState.cx));
          _magState.cy = Math.max(0, Math.min(ir2.height, _magState.cy));
          renderMagnifier(magFrame, mag, _magState);
        };
        window.addEventListener("resize", onResize, { passive: true });
        frame._magResizeHandler = onResize;
      }

      function exitMagnifier(frame) {
        const mag = document.querySelector(".magnifier");
        if (mag) mag.style.display = "none";
        if (frame?._magResizeHandler) {
          window.removeEventListener("resize", frame._magResizeHandler);
          frame._magResizeHandler = null;
        }
        unlockScroll();
        magFrame = null; _magState = null;
        btnMag.textContent = "虫眼鏡";
      }

      btnMag.onclick = () => {
        const f = sections[currentIndex].querySelector(".frame");
        if (magFrame) exitMagnifier(f);
        else enterMagnifier(f);
      };

      /* ========= 2倍ズーム（既存そのまま／虫眼鏡と排反） ========= */
      function enterZoom(frame) {
        if (magFrame) exitMagnifier(magFrame);
        const img = frame.querySelector("img");
        let sx, sy, tx = 0, ty = 0;
        img.style.transform = `translate(0,0) scale(2)`;
        frame.style.touchAction = "none";
        frame.onpointerdown = (e) => { sx = e.clientX; sy = e.clientY; frame.setPointerCapture(e.pointerId); };
        frame.onpointermove = (e) => {
          if (sx == null) return;
          const dx = e.clientX - sx, dy = e.clientY - sy;
          tx += dx; ty += dy;
          const maxX = (img.clientWidth * 2 - frame.clientWidth) / 2;
          const maxY = (img.clientHeight * 2 - frame.clientHeight) / 2;
          tx = Math.max(-maxX, Math.min(maxX, tx));
          ty = Math.max(-maxY, Math.min(maxY, ty));
          img.style.transform = `translate(${tx}px,${ty}px) scale(2)`;
          sx = e.clientX; sy = e.clientY;
        };
        frame.onpointerup = (e) => { sx = null; try { frame.releasePointerCapture(e.pointerId); } catch {} };
        zoomedFrame = frame; btnZoom.textContent = "1倍";
      }
      function exitZoom(frame) {
        const img = frame.querySelector("img");
        img.style.transform = "scale(1)";
        frame.style.touchAction = "pan-y";
        frame.onpointerdown = frame.onpointermove = frame.onpointerup = null;
        zoomedFrame = null; btnZoom.textContent = "2倍";
      }
      btnZoom.onclick = () => {
        const f = sections[currentIndex].querySelector(".frame");
        if (zoomedFrame && zoomedFrame !== f) exitZoom(zoomedFrame);
        if (btnZoom.textContent === "2倍") enterZoom(f);
        else exitZoom(f);
      };
    </script>
  </body>
</html>