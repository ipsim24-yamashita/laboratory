<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
    />
    <title>GENESIS 解答ビューア</title>
    <style>
      :root {
        --dock-h: 0px;
        --line-green: #22c55e;
      }

      html,
      body {
        margin: 0;
        background: #fff;
        color: #111;
        font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif;
        overscroll-behavior-y: contain;
        overflow-x: hidden;
        touch-action: pan-y;
      }
      .wrap {
        width: 100%;
        margin: 0 auto;
        padding: 0 12px;
        box-sizing: border-box;
      }

      /* ===== カルーセル ===== */
      .toc-dock {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        background: #fff;
        border-bottom: 1px solid #eee;
        padding: 8px 0 env(safe-area-inset-top) 0;
      }
      .toc-bar {
        display: flex;
        align-items: center;
        gap: 10px;
        width: 100%;
        box-sizing: border-box;
        overflow: hidden;
      }
      .btn {
        height: 34px;
        padding: 0 12px;
        border: 1px solid #ddd;
        border-radius: 999px;
        background: #f9fafb;
        color: #111;
        cursor: pointer;
        font-size: 14px;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .btn:disabled {
        opacity: 0.4;
        cursor: default;
      }

      .toc-container {
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
      }
      .toc {
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        overscroll-behavior-x: contain;
      }
      .toc::-webkit-scrollbar {
        display: none;
      }
      .toc-list {
        display: flex;
        gap: 8px;
        padding: 0;
        margin: 0;
        list-style: none;
      }
      .toc-list a {
        display: inline-block;
        padding: 6px 12px;
        border: 1px solid #ddd;
        border-radius: 999px;
        background: #f0f6ff;
        color: #0366d6;
        text-decoration: none;
        user-select: none;
        transition: background-color 0.12s, color 0.12s, border-color 0.12s;
      }
      /* 現在地は LINE グリーンで強調 */
      .toc-list a.active {
        background: var(--line-green);
        border-color: #16a34a;
        color: #fff;
      }

      .toolbar-right {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-shrink: 0;
      }

      /* ===== 本文 ===== */
      main {
        padding-top: calc(var(--dock-h) + 12px);
        padding-bottom: 48px;
      }
      section {
        padding: 18px 0;
        border-bottom: 1px solid #f0f0f0;
      }

      /* 画像フレーム：画面幅いっぱい */
      .frame {
        position: relative;
        overflow: hidden;
        width: 100vw;
        max-width: 100vw;
        margin-left: calc(50% - 50vw);
        margin-right: calc(50% - 50vw);
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        background: #fff;
        touch-action: pan-y; /* 1倍時は縦スクロールOK（ズーム/虫眼鏡時はJSでnoneへ） */
      }
      .frame img {
        display: block;
        width: 100%;
        height: auto;
        user-select: none;
        -webkit-user-drag: none;
        pointer-events: none;
        transform-origin: 0 0;
        will-change: transform;
      }

      /* ===== 虫眼鏡（50%サイズ、四辺グラデーション） ===== */
      .magnifier {
        position: absolute;
        display: none;
        pointer-events: none;
        width: 50vw;
        height: 50vh; /* 画面の1/2 */
        border: 2px solid var(--line-green);
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        background-repeat: no-repeat;
        /* background-image / size / position はJSで設定 */
      }
      .magnifier::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        /* それぞれ 32px のフェザー幅。強さは --g* (0〜.5 くらい)  で制御 */
        background: linear-gradient(
            to right,
            rgba(255, 255, 255, var(--gL, 0)),
            rgba(255, 255, 255, 0) 32px
          ),
          linear-gradient(
            to left,
            rgba(255, 255, 255, var(--gR, 0)),
            rgba(255, 255, 255, 0) 32px
          ),
          linear-gradient(
            to bottom,
            rgba(255, 255, 255, var(--gT, 0)),
            rgba(255, 255, 255, 0) 32px
          ),
          linear-gradient(
            to top,
            rgba(255, 255, 255, var(--gB, 0)),
            rgba(255, 255, 255, 0) 32px
          );
        mix-blend-mode: multiply;
      }
    </style>
  </head>
  <body>
    <!-- ===== カルーセル（4ボタン＋チップ＋右端ツール） ===== -->
    <div class="toc-dock" id="toc-dock">
      <div class="wrap">
        <div class="toc-bar">
          <button class="btn" id="car-prev">≪</button>
          <button class="btn" id="car-next">≫</button>

          <div class="toc-container">
            <nav class="toc" id="toc">
              <ul class="toc-list" id="toc-list"></ul>
            </nav>
          </div>

          <div class="toolbar-right">
            <button class="btn" id="pg-prev">←</button>
            <button class="btn" id="pg-next">→</button>
            <button class="btn" id="btn-mag">虫眼鏡</button>
            <button class="btn" id="btn-zoom">2倍</button>
            <a class="btn" id="btn-open" href="#" target="_blank" rel="noopener"
              >原寸</a
            >
          </div>
        </div>
      </div>
    </div>

    <main class="wrap" id="content"></main>

    <script>
      /* ========= 画像リスト（元HTMLを忠実に維持） ========= */
      const BASE = "docs/";
      const groups = [
        { prefix: "1-", start: 1, end: 15 },
        { prefix: "2-", start: 1, end: 12 },
        { prefix: "3-", start: 1, end: 11 },
      ];
      const pad3 = (n) => String(n).padStart(3, "0");
      const files = groups.flatMap((g) =>
        Array.from(
          { length: g.end - g.start + 1 },
          (_, i) => `${g.prefix}${pad3(g.start + i)}.jpeg`
        )
      );

      /* ========= 要素 ========= */
      const tocEl = document.getElementById("toc");
      const tocList = document.getElementById("toc-list");
      const content = document.getElementById("content");
      const btnOpen = document.getElementById("btn-open");
      const btnZoom = document.getElementById("btn-zoom");
      const btnMag = document.getElementById("btn-mag");
      const pgPrev = document.getElementById("pg-prev");
      const pgNext = document.getElementById("pg-next");
      const carPrev = document.getElementById("car-prev");
      const carNext = document.getElementById("car-next");
      const dockEl = document.getElementById("toc-dock");

      /* ========= DOM生成 ========= */
      files.forEach((name, idx) => {
        // TOC
        const li = document.createElement("li");
        const a = document.createElement("a");
        a.href = `#p-${name.replace(/\.[^.]+$/, "")}`;
        a.dataset.index = idx;
        a.textContent = name.replace(".jpeg", "");
        if (idx === 0) a.classList.add("active");
        li.appendChild(a);
        tocList.appendChild(li);

        // セクション
        const sec = document.createElement("section");
        sec.dataset.index = idx;
        sec.id = `p-${name.replace(/\.[^.]+$/, "")}`;
        sec.innerHTML = `
    <figure class="frame">
      <img src="${BASE}${encodeURIComponent(name)}" alt="">
      <div class="magnifier"></div>
    </figure>`;
        content.appendChild(sec);
      });

      /* ========= カルーセル高さを CSS 変数へ ========= */
      function applyDockH() {
        document.documentElement.style.setProperty(
          "--dock-h",
          (dockEl?.offsetHeight || 0) + "px"
        );
      }
      new ResizeObserver(applyDockH).observe(dockEl);
      window.addEventListener("resize", applyDockH);
      applyDockH();

      /* ========= ページ配列 ========= */
      const sections = Array.from(document.querySelectorAll("main section"));
      const tocLinks = Array.from(document.querySelectorAll("#toc-list a"));
      let currentIndex = 0;
      let lastIndex = 0; // 移動方向の判定用

      /* ========= 70%しきい＋カルーセル下線（dock bottom）基準の現在地判定 ========= */
      function detectCurrentByBaseline() {
        const baseline = dockEl.getBoundingClientRect().bottom; // カルーセル下端の線
        let idx = 0;
        for (let i = 0; i < sections.length; i++) {
          const r = sections[i].getBoundingClientRect();
          const th = r.top + r.height * 0.7;
          if (baseline >= th) idx = i + 1;
          else break;
        }
        if (idx >= sections.length) idx = sections.length - 1;
        if (idx !== currentIndex) setActive(idx);
      }

      /* ========= TOC 可視化制御：常に表示域内、進む→右端／戻る→左端に寄せる ========= */
      function ensureTocVisibility(targetIndex, prevIndex) {
        const link = tocLinks[targetIndex];
        if (!link) return;
        const cr = tocEl.getBoundingClientRect();
        const lr = link.getBoundingClientRect();

        const goingForward = targetIndex > prevIndex;
        const goingBackward = targetIndex < prevIndex;

        // すでに全体が見えていれば何もしない
        if (lr.left >= cr.left && lr.right <= cr.right) return;

        // 右へ進むときは右端に合わせる
        if (goingForward && lr.right > cr.right) {
          const delta = lr.right - cr.right;
          tocEl.scrollLeft += Math.ceil(delta);
          return;
        }

        // 左へ戻るときは左端に合わせる
        if (goingBackward && lr.left < cr.left) {
          const delta = lr.left - cr.left;
          tocEl.scrollLeft += Math.floor(delta);
          return;
        }

        // 方向不明（初期判定やジャンプ時）は近い方の端に寄せる
        const overLeft = Math.max(0, cr.left - lr.left);
        const overRight = Math.max(0, lr.right - cr.right);
        if (overRight > overLeft) tocEl.scrollLeft += overRight;
        else tocEl.scrollLeft -= overLeft;
      }

      function setActive(i) {
        lastIndex = currentIndex;
        currentIndex = i;

        // TOC見た目更新（LINEグリーン）
        tocLinks.forEach((el, idx) => el.classList.toggle("active", idx === i));

        // 原寸リンク更新
        const img = sections[i]?.querySelector("img");
        if (img) btnOpen.href = img.currentSrc || img.src;

        // 前後ボタン活性/非活性
        pgPrev.disabled = i <= 0;
        pgNext.disabled = i >= sections.length - 1;

        // 現在チップを可視域へ（端寄せルール適用）
        ensureTocVisibility(i, lastIndex);
      }

      /* スクロール・リサイズ・起動時に判定 */
      window.addEventListener("scroll", detectCurrentByBaseline, {
        passive: true,
      });
      window.addEventListener("resize", () => {
        detectCurrentByBaseline();
        // リサイズでも現在チップが見えるよう再調整
        requestAnimationFrame(() =>
          ensureTocVisibility(currentIndex, lastIndex)
        );
      });
      window.addEventListener("load", () => {
        detectCurrentByBaseline();
        ensureTocVisibility(currentIndex, lastIndex);
      });

      /* ========= ページ移動（瞬時） ========= */
      function scrollToSection(i) {
        const s = sections[i];
        if (!s) return;
        window.scrollTo({ top: s.offsetTop, behavior: "auto" });
        // スクロール直後：現在地再判定→TOCスクロール
        requestAnimationFrame(() => {
          detectCurrentByBaseline();
          ensureTocVisibility(currentIndex, lastIndex);
        });
      }
      tocLinks.forEach((a) =>
        a.addEventListener("click", (e) => {
          e.preventDefault();
          scrollToSection(Number(a.dataset.index));
        })
      );
      pgPrev.addEventListener("click", () => {
        if (currentIndex > 0) scrollToSection(currentIndex - 1);
      });
      pgNext.addEventListener("click", () => {
        if (currentIndex < sections.length - 1)
          scrollToSection(currentIndex + 1);
      });

      /* ========= カルーセル左右（瞬時） ========= */
      function pageSize() {
        return Math.max(200, tocEl.clientWidth * 0.8);
      }
      document.getElementById("car-prev").addEventListener("click", () => {
        tocEl.scrollBy({ left: -pageSize(), behavior: "auto" });
        // ボタン操作後も現在チップが端に来るよう微調整
        requestAnimationFrame(() =>
          ensureTocVisibility(currentIndex, lastIndex)
        );
      });
      document.getElementById("car-next").addEventListener("click", () => {
        tocEl.scrollBy({ left: pageSize(), behavior: "auto" });
        requestAnimationFrame(() =>
          ensureTocVisibility(currentIndex, lastIndex)
        );
      });
      tocEl.addEventListener(
        "scroll",
        () => {
          const max = Math.max(0, tocEl.scrollWidth - tocEl.clientWidth);
          if (tocEl.scrollLeft < 0) tocEl.scrollLeft = 0;
          else if (tocEl.scrollLeft > max) tocEl.scrollLeft = max;
        },
        { passive: true }
      );

      /* ======== 排反制御・ユーティリティ ======== */
      let zoomedFrame = null;
      let magActive = false,
        magFrame = null;
      function disablePageScroll() {
        document.documentElement.style.overflowY = "hidden";
        document.body.style.overflowY = "hidden";
      }
      function enablePageScroll() {
        document.documentElement.style.overflowY = "auto";
        document.body.style.overflowY = "auto";
      }

      /* ======== 2倍拡大（クランプあり、虫眼鏡と排反） ======== */
      function getBaseDims(frame, img) {
        const baseW = frame.clientWidth;
        const ratio =
          img.naturalWidth && img.naturalHeight
            ? img.naturalHeight / img.naturalWidth
            : img.offsetHeight / baseW;
        const baseH = baseW * ratio;
        return { baseW, baseH };
      }
      function clampPan(frame, img, nx, ny, scale) {
        const { baseW, baseH } = getBaseDims(frame, img);
        const dispW = baseW * scale,
          dispH = baseH * scale;
        const fw = frame.clientWidth,
          fh = frame.clientHeight; // fh ≒ baseH
        const minX = Math.min(0, fw - dispW),
          maxX = 0;
        const minY = Math.min(0, fh - dispH),
          maxY = 0;
        return {
          x: Math.max(minX, Math.min(maxX, nx)),
          y: Math.max(minY, Math.min(maxY, ny)),
        };
      }
      function enterZoom(frame) {
        if (magActive && magFrame) exitMagnifier(magFrame); // 排反
        const img = frame.querySelector("img");
        const state = { scale: 2, tx: 0, ty: 0 };
        img.style.transform = `translate(0px,0px) scale(2)`;

        disablePageScroll();
        frame.style.touchAction = "none";

        function onDown(e) {
          e.preventDefault();
          frame.setPointerCapture(e.pointerId);
          state.sx = e.clientX;
          state.sy = e.clientY;
          state.startTx = state.tx;
          state.startTy = state.ty;
        }
        function onMove(e) {
          if (state.sx == null) return;
          e.preventDefault();
          const rawX = state.startTx + (e.clientX - state.sx);
          const rawY = state.startTy + (e.clientY - state.sy);
          const cl = clampPan(frame, img, rawX, rawY, state.scale);
          state.tx = cl.x;
          state.ty = cl.y;
          img.style.transform = `translate(${state.tx}px,${state.ty}px) scale(${state.scale})`;
        }
        function onUp(e) {
          state.sx = state.sy = null;
          try {
            frame.releasePointerCapture(e.pointerId);
          } catch (_) {}
        }

        frame.addEventListener("pointerdown", onDown, { passive: false });
        frame.addEventListener("pointermove", onMove, { passive: false });
        frame.addEventListener("pointerup", onUp, { passive: false });
        frame.addEventListener("pointercancel", onUp, { passive: false });
        frame._zoomHandlers = { onDown, onMove, onUp, state };
        zoomedFrame = frame;
        btnZoom.textContent = "1倍";
      }
      function exitZoom(frame) {
        const img = frame.querySelector("img");
        img.style.transform = "scale(1)";

        enablePageScroll();
        frame.style.touchAction = "pan-y";

        if (frame._zoomHandlers) {
          frame.removeEventListener("pointerdown", frame._zoomHandlers.onDown, {
            passive: false,
          });
          frame.removeEventListener("pointermove", frame._zoomHandlers.onMove, {
            passive: false,
          });
          frame.removeEventListener("pointerup", frame._zoomHandlers.onUp, {
            passive: false,
          });
          frame.removeEventListener("pointercancel", frame._zoomHandlers.onUp, {
            passive: false,
          });
          frame._zoomHandlers = null;
        }
        zoomedFrame = null;
        btnZoom.textContent = "2倍";
      }
      btnZoom.addEventListener("click", () => {
        const frame = sections[currentIndex]?.querySelector(".frame");
        if (!frame) return;
        if (zoomedFrame && zoomedFrame !== frame) exitZoom(zoomedFrame);
        if (btnZoom.textContent === "2倍") enterZoom(frame);
        else exitZoom(frame);
      });

      /* ======== 虫眼鏡（四辺端合わせ・グラデーション可変・排反） ======== */
      function setMagGradient(mag, gL, gR, gT, gB) {
        const scale = 0.45; // 最大濃度
        mag.style.setProperty("--gL", (gL * scale).toFixed(3));
        mag.style.setProperty("--gR", (gR * scale).toFixed(3));
        mag.style.setProperty("--gT", (gT * scale).toFixed(3));
        mag.style.setProperty("--gB", (gB * scale).toFixed(3));
      }
      function positionMagnifier(frame, mag, left, top) {
        const fr = frame.getBoundingClientRect();
        const w = mag.offsetWidth,
          h = mag.offsetHeight;

        // クランプ（レンズの左上をframe内に収める）
        left = Math.max(0, Math.min(fr.width - w, left));
        top = Math.max(0, Math.min(fr.height - h, top));

        // 位置反映（frame内 px）
        mag.style.left = `${left}px`;
        mag.style.top = `${top}px`;

        // 背景：2倍、四辺端合わせ
        const zoom = 2;
        const maxBgX = fr.width * zoom - w; // 右端一致用
        const maxBgY = fr.height * zoom - h; // 下端一致用
        const bgX = -Math.min(left * zoom, maxBgX);
        const bgY = -Math.min(top * zoom, maxBgY);
        mag.style.backgroundPosition = `${bgX}px ${bgY}px`;

        // グラデーション（中央0、端で最大）
        const th = 96; // しきい距離(px)
        const distL = left;
        const distR = fr.width - (left + w);
        const distT = top;
        const distB = fr.height - (top + h);
        const gL = Math.max(0, Math.min(1, 1 - distL / th));
        const gR = Math.max(0, Math.min(1, 1 - distR / th));
        const gT = Math.max(0, Math.min(1, 1 - distT / th));
        const gB = Math.max(0, Math.min(1, 1 - distB / th));
        setMagGradient(mag, gL, gR, gT, gB);
      }

      function enterMagnifier(frame) {
        if (zoomedFrame) exitZoom(zoomedFrame); // 排反
        const mag = frame.querySelector(".magnifier");
        const img = frame.querySelector("img");

        // 背景はフレームの2倍
        mag.style.backgroundImage = `url("${img.currentSrc || img.src}")`;
        mag.style.backgroundSize = `${frame.clientWidth * 2}px ${
          frame.clientHeight * 2
        }px`;
        mag.style.display = "block";

        // 初期位置＝中央
        positionMagnifier(
          frame,
          mag,
          (frame.clientWidth - mag.offsetWidth) / 2,
          (frame.clientHeight - mag.offsetHeight) / 2
        );

        // スクロール停止、レンズ移動
        disablePageScroll();
        frame.style.touchAction = "none";

        let dragging = false,
          sx = 0,
          sy = 0,
          startLeft = 0,
          startTop = 0;
        function onDown(e) {
          e.preventDefault();
          dragging = true;
          frame.setPointerCapture(e.pointerId);
          const r = mag.getBoundingClientRect(),
            fr = frame.getBoundingClientRect();
          sx = e.clientX;
          sy = e.clientY;
          startLeft = r.left - fr.left;
          startTop = r.top - fr.top;
        }
        function onMove(e) {
          if (!dragging) return;
          e.preventDefault();
          const dx = e.clientX - sx,
            dy = e.clientY - sy;
          positionMagnifier(frame, mag, startLeft + dx, startTop + dy);
        }
        function onUp(e) {
          dragging = false;
          try {
            frame.releasePointerCapture(e.pointerId);
          } catch (_) {}
        }

        frame.addEventListener("pointerdown", onDown, { passive: false });
        frame.addEventListener("pointermove", onMove, { passive: false });
        frame.addEventListener("pointerup", onUp, { passive: false });
        frame.addEventListener("pointercancel", onUp, { passive: false });
        frame._magHandlers = { onDown, onMove, onUp };

        magFrame = frame;
        magActive = true;
        btnMag.textContent = "オフ";
      }
      function exitMagnifier(frame) {
        const mag = frame.querySelector(".magnifier");
        mag.style.display = "none";
        setMagGradient(mag, 0, 0, 0, 0);

        enablePageScroll();
        frame.style.touchAction = "pan-y";

        if (frame._magHandlers) {
          frame.removeEventListener("pointerdown", frame._magHandlers.onDown, {
            passive: false,
          });
          frame.removeEventListener("pointermove", frame._magHandlers.onMove, {
            passive: false,
          });
          frame.removeEventListener("pointerup", frame._magHandlers.onUp, {
            passive: false,
          });
          frame.removeEventListener("pointercancel", frame._magHandlers.onUp, {
            passive: false,
          });
          frame._magHandlers = null;
        }
        magFrame = null;
        magActive = false;
        btnMag.textContent = "虫眼鏡";
      }
      btnMag.addEventListener("click", () => {
        const frame = sections[currentIndex]?.querySelector(".frame");
        if (!frame) return;
        if (magActive && magFrame === frame) exitMagnifier(frame);
        else {
          if (magActive && magFrame && magFrame !== frame)
            exitMagnifier(magFrame);
          enterMagnifier(frame);
        }
      });

      /* ========= iOSのダブルタップズーム無効 ========= */
      let lastTouchEnd = 0;
      document.addEventListener(
        "touchend",
        (e) => {
          const now = Date.now();
          if (now - lastTouchEnd <= 400) e.preventDefault();
          lastTouchEnd = now;
        },
        { passive: false }
      );

      /* ========= 初期化 ========= */
      (function init() {
        // 初回の現在地判定
        detectCurrentByBaseline();

        // リサイズ時：ズーム/虫眼鏡中の制約計算を更新 & 現在地/TOC再調整
        window.addEventListener("resize", () => {
          if (zoomedFrame && zoomedFrame._zoomHandlers) {
            const frame = zoomedFrame;
            const img = frame.querySelector("img");
            const st = frame._zoomHandlers.state;
            const cl = clampPan(frame, img, st.tx, st.ty, st.scale);
            st.tx = cl.x;
            st.ty = cl.y;
            img.style.transform = `translate(${st.tx}px,${st.ty}px) scale(${st.scale})`;
          }
          if (magActive && magFrame) {
            const frame = magFrame;
            const mag = frame.querySelector(".magnifier");
            positionMagnifier(
              frame,
              mag,
              (frame.clientWidth - mag.offsetWidth) / 2,
              (frame.clientHeight - mag.offsetHeight) / 2
            );
            mag.style.backgroundSize = `${frame.clientWidth * 2}px ${
              frame.clientHeight * 2
            }px`;
          }
          detectCurrentByBaseline();
          requestAnimationFrame(() =>
            ensureTocVisibility(currentIndex, lastIndex)
          );
        });
      })();
    </script>
  </body>
</html>
