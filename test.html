<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- ピンチ禁止 & ズーム禁止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>GENESIS 解答ビューア</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            linegreen: '#22c55e',   // 現在ページ用
            carYellow: '#fde047',   // yellow-300
          }
        }
      }
    }
  </script>

  <style>
    /* iPadのちらつき/消失対策 */
    .toc-dock { transform: translateZ(0); -webkit-transform: translateZ(0); will-change: transform; }

    /* カルーセルはユーザー手動スクロール不可（固定） */
    .toc { overflow: hidden; -webkit-overflow-scrolling: auto; position: relative; height: 44px; }
    .toc-list { padding-left: 8px; padding-right: 8px; }

    /* 虫眼鏡（固定・中央） */
    .magnifier {
      position: fixed; z-index: 3000; display: none;
      border: 2px solid #22c55e; border-radius: 12px; overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,.25); background: #fff;
      touch-action: none; -webkit-user-select: none; user-select: none;
    }
    .magnifier img {
      position: absolute; left: 0; top: 0;
      user-select: none; pointer-events: none; -webkit-user-drag: none;
      transform-origin: 0 0;
    }

    /* 8方向ボタン（丸・透過） */
    .mag-btn {
      position: absolute; width: 44px; height: 44px; border-radius: 9999px;
      background: transparent; border: 2px solid rgba(255,255,255,0.9);
      box-shadow: 0 1px 2px rgba(0,0,0,.12);
      -webkit-tap-highlight-color: transparent; user-select: none;
      touch-action: manipulation; transition: transform .08s ease;
    }
    .mag-btn:active { transform: scale(.98); }
    .mag-btn.n  { top: 8px; left: 50%; transform: translate(-50%,0); }
    .mag-btn.s  { bottom: 8px; left: 50%; transform: translate(-50%,0); }
    .mag-btn.w  { left: 8px; top: 50%; transform: translate(0,-50%); }
    .mag-btn.e  { right: 8px; top: 50%; transform: translate(0,-50%); }
    .mag-btn.nw { top: 8px; left: 8px; }
    .mag-btn.ne { top: 8px; right: 8px; }
    .mag-btn.sw { bottom: 8px; left: 8px; }
    .mag-btn.se { bottom: 8px; right: 8px; }

    /* 虫眼鏡ONのボタン色（#f97316） */
    .btn-on { background: #f97316 !important; color: #fff !important; border-color: #f97316 !important; box-shadow: 0 1px 2px rgba(0,0,0,.16); }
  </style>
</head>

<body class="bg-white text-neutral-900 touch-manipulation select-none">
  <!-- 固定カルーセル -->
  <div id="toc-dock" class="toc-dock fixed top-0 left-0 right-0 z-[2000] bg-white border-b border-neutral-200 pt-2 pb-2">
    <div class="max-w-full mx-auto px-3">
      <div class="flex items-center gap-2 w-full box-border">
        <!-- ≪ / ≫（黄色） -->
        <button id="car-prev" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">≪</button>
        <button id="car-next" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">≫</button>

        <!-- ページリスト（固定） -->
        <div class="flex-1 min-w-0">
          <nav id="toc" class="toc flex items-center">
            <ul id="toc-list" class="toc-list flex gap-2 items-center"></ul>
          </nav>
        </div>

        <!-- 右側ツール -->
        <div class="flex items-center gap-2 shrink-0">
          <button id="pg-prev" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">←</button>
          <button id="pg-next" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">→</button>
          <button id="btn-mag" class="h-9 px-3 rounded-full bg-neutral-100 text-neutral-900 border border-neutral-300">虫眼鏡</button>
          <a id="btn-open" href="#" target="_blank" rel="noopener" class="h-9 px-3 rounded-full bg-neutral-100 text-neutral-900 border border-neutral-300 inline-flex items-center justify-center">Tab</a>
        </div>
      </div>
    </div>
  </div>

  <!-- 本文 -->
  <main id="content" class="max-w-full mx-auto px-3"></main>

  <!-- グローバル虫眼鏡 -->
  <div id="global-mag" class="magnifier">
    <img alt="" />
    <button class="mag-btn n"  aria-label="上"></button>
    <button class="mag-btn s"  aria-label="下"></button>
    <button class="mag-btn w"  aria-label="左"></button>
    <button class="mag-btn e"  aria-label="右"></button>
    <button class="mag-btn nw" aria-label="左上"></button>
    <button class="mag-btn ne" aria-label="右上"></button>
    <button class="mag-btn sw" aria-label="左下"></button>
    <button class="mag-btn se" aria-label="右下"></button>
  </div>

  <script>
    /* ===== 画像リスト ===== */
    const BASE = "docs/";
    const groups = [
      { prefix: "1-", start: 1, end: 15 },
      { prefix: "2-", start: 1, end: 12 },
      { prefix: "3-", start: 1, end: 11 },
    ];
    const pad3 = (n) => String(n).padStart(3, "0");
    const files = groups.flatMap(g => Array.from({ length: g.end - g.start + 1 }, (_, i) => `${g.prefix}${pad3(g.start + i)}.jpeg`));

    /* ===== 要素 ===== */
    const tocDock = document.getElementById("toc-dock");
    const tocEl   = document.getElementById("toc");
    const tocList = document.getElementById("toc-list");
    const content = document.getElementById("content");
    const btnOpen = document.getElementById("btn-open");
    const btnMag  = document.getElementById("btn-mag");
    const pgPrev  = document.getElementById("pg-prev");
    const pgNext  = document.getElementById("pg-next");
    const carPrev = document.getElementById("car-prev");
    const carNext = document.getElementById("car-next");

    /* ===== DOM生成 ===== */
    files.forEach((name, idx) => {
      // ページチップ
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = `#p-${name.replace(/\.[^.]+$/, "")}`;
      a.dataset.index = idx;
      a.textContent = name.replace(".jpeg", "");
      a.className = "inline-block px-3 py-1.5 border rounded-full select-none whitespace-nowrap border-neutral-300 bg-blue-50 text-blue-600";
      if (idx === 0) a.classList.add("bg-linegreen","text-white","border-green-600");
      li.appendChild(a);
      tocList.appendChild(li);

      // セクション
      const sec = document.createElement("section");
      sec.dataset.index = idx;
      sec.id = `p-${name.replace(/\.[^.]+$/, "")}`;
      sec.className = "py-4 border-b border-neutral-100";
      sec.innerHTML = `
        <figure class="relative overflow-hidden w-screen max-w-screen mx-[calc(50%-50vw)] border border-neutral-200 rounded-xl bg-white touch-pan-y">
          <img src="${BASE}${encodeURIComponent(name)}" alt=""
               class="block w-full h-auto select-none pointer-events-none"
               draggable="false">
        </figure>`;
      content.appendChild(sec);
    });

    /* ===== 固定バーの高さを本文に反映 ===== */
    function applyDockPadding() {
      const h = tocDock?.offsetHeight || 60;
      content.style.paddingTop = (h + 12) + "px";
    }
    new ResizeObserver(applyDockPadding).observe(tocDock);
    window.addEventListener("resize", applyDockPadding);
    applyDockPadding();

    /* ===== 現在セクション検出 ===== */
    const sections = Array.from(document.querySelectorAll("main section"));
    const tocLinks = Array.from(document.querySelectorAll("#toc-list a"));
    let currentIndex = 0;

    function setActive(i, ensureVisible=false) {
      currentIndex = i;
      tocLinks.forEach((el, idx) => {
        el.classList.toggle("bg-linegreen", idx === i);
        el.classList.toggle("text-white",   idx === i);
        el.classList.toggle("border-green-600", idx === i);
        el.classList.toggle("bg-blue-50",   idx !== i);
        el.classList.toggle("text-blue-600",idx !== i);
        el.classList.toggle("border-neutral-300", idx !== i);
      });
      const img = sections[i]?.querySelector("img");
      if (img) btnOpen.href = img.currentSrc || img.src;

      // ←/→は現在チップを必ず可視化（≪/≫は不要）
      if (ensureVisible) {
        const link = tocLinks[i];
        const lr = link.getBoundingClientRect();
        const tr = tocEl.getBoundingClientRect();
        if (lr.left < tr.left) {
          tocEl.scrollLeft += (lr.left - tr.left); // 即時
        } else if (lr.right > tr.right) {
          tocEl.scrollLeft += (lr.right - tr.right); // 即時
        }
      }
    }

    function detectCurrentPage() {
      const baseline = tocDock.getBoundingClientRect().bottom;
      let idx = 0;
      for (let i = 0; i < sections.length; i++) {
        const r = sections[i].getBoundingClientRect();
        const th = r.top + r.height * 0.6;
        if (baseline >= th) idx = i + 1;
      }
      const last = sections[sections.length - 1].getBoundingClientRect();
      if (last.bottom <= window.innerHeight) idx = sections.length - 1;
      if (idx >= sections.length) idx = sections.length - 1;
      if (idx !== currentIndex) setActive(idx, false);
    }
    window.addEventListener("scroll", detectCurrentPage, { passive: true });
    window.addEventListener("resize", detectCurrentPage);
    window.addEventListener("load", detectCurrentPage);

    /* ===== カルーセルのユーザースクロールを完全禁止 ===== */
    tocEl.addEventListener('wheel', (e) => { e.preventDefault(); }, { passive:false });
    let touching = false;
    tocEl.addEventListener('touchstart', () => { touching = true; }, { passive:true });
    tocEl.addEventListener('touchmove', (e)=>{ if (touching) e.preventDefault(); }, { passive:false });
    tocEl.addEventListener('touchend',  () => { touching=false; });

    /* ===== ページ移動 ===== */
    function scrollToSection(i, ensureVisible=false) {
      const s = sections[i]; if (!s) return;
      window.scrollTo({ top: s.offsetTop, behavior: "auto" });
      requestAnimationFrame(() => { detectCurrentPage(); if (ensureVisible) setActive(i, true); });
    }

    // ←/→：現在ページチップを必ず可視化
    pgPrev.onclick = () => { deactivateMag(); const next = Math.max(0, currentIndex - 1); scrollToSection(next, true); };
    pgNext.onclick = () => { deactivateMag(); const next = Math.min(sections.length - 1, currentIndex + 1); scrollToSection(next, true); };

    // ≪/≫：長押しで高速連続スクロール（現在ページの可視化は不要）
    function pageSize() {
      const tr = tocEl.getBoundingClientRect();
      return Math.max(200, tr.width * 0.8);
    }
    let carTimer = null;
    function startCarScroll(dir) { // dir: -1 (≪), +1 (≫)
      if (carTimer) return;
      const step = Math.round(pageSize() * 0.25); // 細かく刻む
      const tick = () => tocEl.scrollBy({ left: dir * step, behavior: 'auto' });
      tick();
      carTimer = setInterval(tick, 60);
    }
    function stopCarScroll() { if (carTimer) { clearInterval(carTimer); carTimer = null; } }
    ['pointerup','pointercancel','pointerleave','touchend'].forEach(ev => {
      carPrev.addEventListener(ev, stopCarScroll);
      carNext.addEventListener(ev, stopCarScroll);
    });
    carPrev.addEventListener('pointerdown', (e)=>{ e.preventDefault(); deactivateMag(); startCarScroll(-1); });
    carNext.addEventListener('pointerdown', (e)=>{ e.preventDefault(); deactivateMag(); startCarScroll(+1); });

    // 目次クリック
    tocLinks.forEach(a => a.onclick = (e) => {
      e.preventDefault();
      deactivateMag();
      scrollToSection(Number(a.dataset.index), true);
    });

    /* ===== 虫眼鏡（1.5x / アスペクト維持 / 範囲外非表示） ===== */
    const magEl = document.getElementById('global-mag');
    const magImg = magEl.querySelector('img');
    const magState = { on:false, frame:null, cx:0, cy:0, scale:1.5 };

    function visibleAreaBounds() {
      return { left: 0, right: window.innerWidth, top: tocDock.getBoundingClientRect().bottom, bottom: window.innerHeight };
    }

    // レンズが常に画像の内側だけを見るように中心を拘束（表示座標系で計算）
function enforceCenterWithinImage() {
  if (!magState.on || !magState.frame) return;
  const img = magState.frame.querySelector("img");
  const iw = img.clientWidth || 1;
  const ih = img.clientHeight || 1;
  const s = magState.scale;

  // レンズの半径を画像座標に換算（w,h はレンズのピクセルサイズ）
  const w = magEl.clientWidth || 1;
  const h = magEl.clientHeight || 1;
  const marginX = (w / 2) / s;
  const marginY = (h / 2) / s;

  // 画像の端から margin を越えないように中心を拘束
  const minCX = Math.max(0, marginX);
  const maxCX = Math.max(minCX, iw - marginX);
  const minCY = Math.max(0, marginY);
  const maxCY = Math.max(minCY, ih - marginY);

  magState.cx = Math.min(Math.max(magState.cx, minCX), maxCX);
  magState.cy = Math.min(Math.max(magState.cy, minCY), maxCY);
}

    // 可視領域90%に、元画像のアスペクト比で最大フィット＆中央配置
// 可視領域(カルーセル下端〜画面端)の 95% を、
// 元画像のアスペクト比を正確に保ったまま最大フィット＆中央配置

// 可視領域(カルーセル下端〜画面端)の 96% x 92% を上限に
// 元画像のアスペクト比で最大フィット（フレーム自体が歪まない）// 可視領域の 96%×92% を上限にしつつ、拡大後の画像よりレンズを大きくしない
// レンズ自体は元画像のアスペクト比でフィット（歪みゼロ）
function sizeAndCenterMagnifierKeepAspect() {
  const vb = visibleAreaBounds();
  const maxW = (vb.right - vb.left) * 0.96; // 横を広めに
  const maxH = (vb.bottom - vb.top) * 0.92; // 縦は少し余裕

  const pageImg = magState.frame.querySelector("img");
  // 元解像度の比率でフレーム比を決める
  const natW = pageImg.naturalWidth  || pageImg.clientWidth  || 1;
  const natH = pageImg.naturalHeight || pageImg.clientHeight || 1;
  const aspect = natW / natH;

  // ページ上の表示サイズ（画像が画面幅に縮んでいる分）
  const dispW = pageImg.clientWidth  || natW;
  const dispH = pageImg.clientHeight || natH;

  // 拡大後の画像サイズ（この範囲内にレンズを収める）
  const s = magState.scale;              // 1.5 固定
  const imgW = dispW * s;
  const imgH = dispH * s;

  // レンズの最大サイズ＝「可視領域上限」かつ「拡大画像サイズ」以下
  const hardMaxW = Math.min(maxW, imgW);
  const hardMaxH = Math.min(maxH, imgH);

  // 元画像のアスペクト比で最大化
  let w = hardMaxW;
  let h = w / aspect;
  if (h > hardMaxH) { h = hardMaxH; w = h * aspect; }

  w = Math.round(w);
  h = Math.round(h);

  magEl.style.width  = `${w}px`;
  magEl.style.height = `${h}px`;
  magEl.style.left   = `${Math.round((vb.left + vb.right  - w)/2)}px`;
  magEl.style.top    = `${Math.round((vb.top  + vb.bottom - h)/2)}px`;

  // レンズが決まったら、中心が必ず画像内に収まるよう拘束
  enforceCenterWithinImage();
}


    function lockScroll(){ document.body.style.overflow="hidden"; document.body.style.touchAction="none"; }
    function unlockScroll(){ document.body.style.overflow=""; document.body.style.touchAction=""; }

    function resetMagCenter() {
      const img = magState.frame.querySelector("img");
      const iw = img.clientWidth, ih = img.clientHeight;
      magState.cx = iw/2; magState.cy = ih/2;
    }

    // レンズ内描画：元解像度ベースで拡大（歪みゼロ）＆範囲外はクランプ
    // レンズ内描画：歪みゼロ＆白紙なし（拡大画像サイズ内に収める）
function renderMagnifier() {
  if (!magState.on || !magState.frame) return;

  const pageImg = magState.frame.querySelector("img");

  // 元解像度（比率用）とページ表示倍率
  const natW = pageImg.naturalWidth  || 1;
  const natH = pageImg.naturalHeight || 1;
  const dispW = pageImg.clientWidth  || natW;
  const dispH = pageImg.clientHeight || natH;

  const s  = magState.scale;                // 1.5
  const sx = (dispW / natW) * s;            // 横方向のCSS拡大率
  const sy = (dispH / natH) * s;            // 縦方向のCSS拡大率（理論上sx=sy）

  // レンズの実サイズ
  const w = magEl.clientWidth  || 1;
  const h = magEl.clientHeight || 1;

  // レンズが画像外を見ないよう中心を拘束
  enforceCenterWithinImage();

  // レンズ内に描画する拡大画像のサイズ（CSS px）
  const cssW = natW * sx;
  const cssH = natH * sy;
  const src  = pageImg.currentSrc || pageImg.src;
  if (magImg.src !== src) magImg.src = src;
  magImg.style.width  = `${cssW}px`;
  magImg.style.height = `${cssH}px`;

  // natural座標で中心 → CSS座標へ変換してオフセット
  const cxNat = magState.cx / (dispW / natW);
  const cyNat = magState.cy / (dispH / natH);

  let offX = Math.round(w/2 - cxNat * sx);
  let offY = Math.round(h/2 - cyNat * sy);

  // 画像の端内に収める（白紙が出ないようクランプ）
  const minX = w - cssW, maxX = 0;
  const minY = h - cssH, maxY = 0;
  offX = Math.max(minX, Math.min(maxX, offX));
  offY = Math.max(minY, Math.min(maxY, offY));

  magImg.style.transform = `translate(${offX}px, ${offY}px)`;
}

    function enterMagnifier(frame) {
      magState.on = true; magState.frame = frame;
      magEl.style.display = "block";           // 先に表示してサイズ計測を安定
      sizeAndCenterMagnifierKeepAspect();
      // iOS初期サブピクセル誤差対策で1フレーム後に再計算
      requestAnimationFrame(() => {
        sizeAndCenterMagnifierKeepAspect();
        renderMagnifier();
      });
      resetMagCenter();
      renderMagnifier();
      lockScroll();
      attachMagPointerHandlers();
      setUiStates();
    }

    function exitMagnifier() {
      magState.on = false;
      magEl.style.display = "none";
      unlockScroll();
      detachMagPointerHandlers();
      setUiStates();
    }

    function deactivateMag(){ if (magState.on) exitMagnifier(); }

    // 1本指/2本指パン（平均移動で中心を動かす）
    let activePointers = new Map(); // id -> {x,y}
    function attachMagPointerHandlers() {
      magEl.addEventListener('pointerdown', onMagPointerDown);
      magEl.addEventListener('pointermove', onMagPointerMove);
      magEl.addEventListener('pointerup', onMagPointerUpCancel);
      magEl.addEventListener('pointercancel', onMagPointerUpCancel);
      magEl.addEventListener('pointerleave', onMagPointerUpCancel);
    }
    function detachMagPointerHandlers() {
      magEl.removeEventListener('pointerdown', onMagPointerDown);
      magEl.removeEventListener('pointermove', onMagPointerMove);
      magEl.removeEventListener('pointerup', onMagPointerUpCancel);
      magEl.removeEventListener('pointercancel', onMagPointerUpCancel);
      magEl.removeEventListener('pointerleave', onMagPointerUpCancel);
      activePointers.clear();
    }
    function avg(map){ let sx=0, sy=0, n=0; map.forEach(p=>{ sx+=p.x; sy+=p.y; n++; }); return {x: n? sx/n : 0, y: n? sy/n : 0}; }
    let lastAvg = null;
    function onMagPointerDown(e){
      magEl.setPointerCapture(e.pointerId);
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      lastAvg = avg(activePointers);
    }
    function onMagPointerMove(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
      const curr = avg(activePointers);
      if (lastAvg){
        const dx = curr.x - lastAvg.x;
        const dy = curr.y - lastAvg.y;
        const img = magState.frame.querySelector("img");
        const iw = img.clientWidth, ih = img.clientHeight;
magState.cx = Math.max(0, Math.min(iw,  magState.cx + dx * stepX));
magState.cy = Math.max(0, Math.min(ih,  magState.cy + dy * stepY));
enforceCenterWithinImage();
renderMagnifier();
      }
      lastAvg = curr;
    }
    function onMagPointerUpCancel(e){
      activePointers.delete(e.pointerId);
      lastAvg = avg(activePointers);
    }

    // 8方向ボタン：1クリックで1/8移動
    const dirMap = { n:[0,-1], s:[0,1], w:[-1,0], e:[1,0], nw:[-1,-1], ne:[1,-1], sw:[-1,1], se:[1,1] };
    document.querySelectorAll('.mag-btn').forEach(btn=>{
      const dir = Array.from(btn.classList).find(c=>dirMap[c]);
      const [dx,dy] = dirMap[dir];
      btn.addEventListener('click', ()=>{
        if (!magState.on) return;
        const img = magState.frame.querySelector("img");
        const iw = img.clientWidth, ih = img.clientHeight;
        const stepX = iw / 8, stepY = ih / 8;
        magState.cx = Math.max(0, Math.min(iw,  magState.cx + dx * stepX));
        magState.cy = Math.max(0, Math.min(ih,  magState.cy + dy * stepY));
        renderMagnifier();
      });
    });

    // 虫眼鏡ボタン（色は setUiStates で制御）
    btnMag.onclick = () => {
      const frame = sections[currentIndex].querySelector("figure");
      if (magState.on) exitMagnifier(); else enterMagnifier(frame);
    };

    // ウィンドウサイズ変化：再配置
    const onResize = () => { if (!magState.on) return; sizeAndCenterMagnifierKeepAspect(); renderMagnifier(); };
    window.addEventListener("resize", onResize, { passive: true });

    // 初期アクティブ
    setActive(0,false);

    // 虫眼鏡ボタンのON/OFF色更新
    function setUiStates() {
      const on = magState?.on === true;
      btnMag.classList.toggle('btn-on', on);
    }

    /* ===== 全域：ピンチ/ダブルタップ禁止 ===== */
    ['gesturestart','gesturechange','gestureend'].forEach(t => {
      window.addEventListener(t, e => e.preventDefault(), { passive:false });
    });
    window.addEventListener('dblclick', e => e.preventDefault(), { passive:false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive:false });
  </script>
</body>
</html>