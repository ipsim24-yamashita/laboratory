<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- ブラウザ標準のページズームを無効化（自前ピンチのみ有効） -->
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>GENESIS 解答ビューア</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            linegreen: '#22c55e',
            carYellow: '#fde047'
          }
        }
      }
    }
  </script>

  <style>
    /* カルーセル（固定） */
    .toc-dock { transform: translateZ(0); -webkit-transform: translateZ(0); will-change: transform; }
    .toc { overflow: hidden; -webkit-overflow-scrolling: auto; position: relative; height: 44px; }
    .toc-list { padding-left: 8px; padding-right: 8px; }

    /* 本文全体のズーム対象 */
    #zoom-area {
      transform-origin: 0 0;
      will-change: transform;
      /* JSで scale>1 or ピンチ中のみ 'none' に切替。初期は縦スクロールOK */
      touch-action: pan-y;
    }
    /* 子要素でもブラウザ標準ジェスチャが発動しないよう保険（iOS対策） */
    #zoom-area * { touch-action: none; }

    /* ページ画像 */
    .page-img {
      display: block;
      width: 100%;
      height: auto;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none; /* イベントは親で受ける */
    }
    html, body { overscroll-behavior-y: contain; }  /* 上下ビヨーン抑制 */
    #zoom-area, #zoom-area * { user-select: none; } /* 画像やテキストを選択不可に */
    /* これを必ず入れてください（本文ズームは常に自前） */
    #zoom-area { touch-action: none; }
  </style>
</head>

<body class="bg-white text-neutral-900 select-none">

  <!-- 固定カルーセル -->
  <div id="toc-dock" class="toc-dock fixed top-0 left-0 right-0 z-[2000] bg-white border-b border-neutral-200 pt-2 pb-2">
    <div class="max-w-full mx-auto px-3">
      <div class="flex items-center gap-2 w-full">
        <button id="car-prev" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">≪</button>
        <button id="car-next" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">≫</button>

        <div class="flex-1 min-w-0">
          <nav id="toc" class="toc flex items-center">
            <ul id="toc-list" class="toc-list flex gap-2 items-center"></ul>
          </nav>
        </div>

        <button id="pg-prev" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">←</button>
        <button id="pg-next" class="h-9 px-3 rounded-full bg-carYellow text-black border border-yellow-300">→</button>
        <a id="btn-open" href="#" target="_blank" rel="noopener"
           class="h-9 px-3 rounded-full bg-neutral-100 text-neutral-900 border border-neutral-300 flex items-center justify-center">Tab</a>
      </div>
    </div>
  </div>

  <!-- 本文（ズーム対象をラップ） -->
  <main id="content" class="max-w-full mx-auto px-3">
    <div id="zoom-area"></div>
  </main>

  <script>
    /* ===== 画像リスト ===== */
    const BASE = "docs/";
    const groups = [
      { prefix: "1-", start: 1, end: 15 },
      { prefix: "2-", start: 1, end: 12 },
      { prefix: "3-", start: 1, end: 11 },
    ];
    const pad3 = (n) => String(n).padStart(3, "0");
    const files = groups.flatMap(g =>
      Array.from({ length: g.end - g.start + 1 }, (_, i) => `${g.prefix}${pad3(g.start + i)}.jpeg`)
    );

    /* ===== 要素 ===== */
    const tocDock = document.getElementById("toc-dock");
    const tocEl = document.getElementById("toc");
    const tocList = document.getElementById("toc-list");
    const zoomArea = document.getElementById("zoom-area");
    const btnOpen = document.getElementById("btn-open");
    const pgPrev = document.getElementById("pg-prev");
    const pgNext = document.getElementById("pg-next");
    const carPrev = document.getElementById("car-prev");
    const carNext = document.getElementById("car-next");

    /* ===== DOM生成 ===== */
    files.forEach((name, idx) => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = `#p-${name.replace(/\.[^.]+$/, "")}`;
      a.dataset.index = idx;
      a.textContent = name.replace(".jpeg", "");
      a.className = "inline-block px-3 py-1.5 border rounded-full select-none whitespace-nowrap border-neutral-300 bg-blue-50 text-blue-600";
      if (idx === 0) a.classList.add("bg-linegreen","text-white","border-green-600");
      li.appendChild(a);
      tocList.appendChild(li);

      const sec = document.createElement("section");
      sec.id = `p-${name.replace(/\.[^.]+$/, "")}`;
      sec.className = "py-4 border-b border-neutral-100";
      sec.innerHTML = `
        <figure class="relative border border-neutral-200 rounded-xl bg-white overflow-hidden">
          <img src="${BASE}${encodeURIComponent(name)}" alt="" class="page-img">
        </figure>`;
      zoomArea.appendChild(sec);
    });

    /* ===== 固定バー高さを本文に反映 ===== */
    function applyDockPadding() {
      const h = tocDock?.offsetHeight || 60;
      document.getElementById('content').style.paddingTop = (h + 12) + "px";
    }
    new ResizeObserver(applyDockPadding).observe(tocDock);
    window.addEventListener("resize", applyDockPadding);
    applyDockPadding();

    /* ===== 現在ページ & Tabリンク ===== */
    const sections = Array.from(document.querySelectorAll("main section"));
    const tocLinks = Array.from(document.querySelectorAll("#toc-list a"));
    let currentIndex = 0;

    function setActive(i, ensureVisible=false) {
      currentIndex = i;
      tocLinks.forEach((el, idx) => {
        el.classList.toggle("bg-linegreen", idx === i);
        el.classList.toggle("text-white",   idx === i);
        el.classList.toggle("border-green-600", idx === i);
        el.classList.toggle("bg-blue-50",   idx !== i);
        el.classList.toggle("text-blue-600",idx !== i);
        el.classList.toggle("border-neutral-300", idx !== i);
      });
      const img = sections[i]?.querySelector("img");
      if (img) btnOpen.href = img.currentSrc || img.src;

      if (ensureVisible) {
        const link = tocLinks[i];
        const lr = link.getBoundingClientRect();
        const tr = tocEl.getBoundingClientRect();
        if (lr.left < tr.left)        tocEl.scrollLeft += (lr.left - tr.left);
        else if (lr.right > tr.right) tocEl.scrollLeft += (lr.right - tr.right);
      }
    }
    function detectCurrentPage() {
      const baseline = tocDock.getBoundingClientRect().bottom;
      let idx = 0;
      for (let i = 0; i < sections.length; i++) {
        const r = sections[i].getBoundingClientRect();
        const th = r.top + r.height * 0.6;
        if (baseline >= th) idx = i + 1;
      }
      const last = sections[sections.length - 1].getBoundingClientRect();
      if (last.bottom <= window.innerHeight) idx = sections.length - 1;
      if (idx >= sections.length) idx = sections.length - 1;
      if (idx !== currentIndex) setActive(idx, false);
    }
    window.addEventListener("scroll", detectCurrentPage, { passive: true });
    window.addEventListener("resize", detectCurrentPage);
    window.addEventListener("load", detectCurrentPage);

    /* ===== ページ送り ===== */
    pgPrev.onclick = () => { const next = Math.max(0, currentIndex - 1); window.scrollTo({ top: sections[next].offsetTop, behavior: "auto" }); setActive(next, true); };
    pgNext.onclick = () => { const next = Math.min(sections.length - 1, currentIndex + 1); window.scrollTo({ top: sections[next].offsetTop, behavior: "auto" }); setActive(next, true); };

    /* ===== カルーセル 長押し ===== */
    function pageSize(){ const tr=tocEl.getBoundingClientRect(); return Math.max(200, tr.width*0.8); }
    let carTimer=null;
    function startCarScroll(dir){ if(carTimer) return; const step=Math.round(pageSize()*0.25); const tick=()=>tocEl.scrollBy({left:dir*step,behavior:'auto'}); tick(); carTimer=setInterval(tick,60); }
    function stopCarScroll(){ if(carTimer){ clearInterval(carTimer); carTimer=null; } }
    ["pointerup","pointercancel","pointerleave","touchend"].forEach(ev=>{ carPrev.addEventListener(ev,stopCarScroll); carNext.addEventListener(ev,stopCarScroll); });
    carPrev.addEventListener("pointerdown", e=>{ e.preventDefault(); startCarScroll(-1); });
    carNext.addEventListener("pointerdown", e=>{ e.preventDefault(); startCarScroll(+1); });
    tocLinks.forEach(a => a.onclick = (e)=>{ e.preventDefault(); const i=Number(a.dataset.index); window.scrollTo({top:sections[i].offsetTop, behavior:"auto"}); setActive(i, true); });

    /* === ここから：本文全体ピンチズーム（カルーセル除外） === */
    // 本文全体（#zoom-area）に対するピンチズーム＆パンを初期化
// 仕様: 最小1 / 最大2、拡大中はスクロール抑止、ホイールはパンに割当て

    // 本文全体（#zoom-area）のピンチズーム＆パンを初期化
// 仕様: 最小1 / 最大2、scale==1は1本指でページスクロール、scale>1はパン
    function initGlobalZoom() {
  const area = document.getElementById('zoom-area');
  if (!area) return;

  // --- 状態 ---
  let scale = 1, tx = 0, ty = 0;
  let startScale = 1, startTx = 0, startTy = 0;
  let startDist = 0, startMid = { x: 0, y: 0 };
  const pts = new Map();

  const MIN_SCALE = 1;
  const MAX_SCALE = 2;

  // --- ユーティリティ ---
  const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
  const mid  = (a, b) => ({ x: (a.x + b.x) / 2, y: (a.y + b.y) });
  const apply = () => { area.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`; };

  // iOS のネイティブジェスチャ無効化（自前のみ）
  ['gesturestart', 'gesturechange', 'gestureend', 'dblclick'].forEach(t => {
    area.addEventListener(t, e => e.preventDefault(), { passive: false });
  });

  // CSS 側で #zoom-area { touch-action:none } にしておくこと
  // （ブラウザのスクロール/ピンチを完全に止め、ここで制御）

  // --- ポインタ操作 ---
  function onPointerDown(e) {
    area.setPointerCapture(e.pointerId);
    pts.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if (pts.size === 2) {
      const [p1, p2] = [...pts.values()];
      startDist  = dist(p1, p2) || 1;
      startMid   = mid(p1, p2);
      startScale = scale;
      startTx = tx; startTy = ty;
    } else if (pts.size === 1) {
      startMid = { x: e.clientX, y: e.clientY };
    }
  }

  function onPointerMove(e) {
    if (!pts.has(e.pointerId)) return;
    pts.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pts.size === 2) {
      // 2本指ピンチ（中心固定）
      const [p1, p2] = [...pts.values()];
      const curDist = dist(p1, p2) || 1;
      let nextScale = startScale * (curDist / (startDist || 1));
      nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, nextScale));

      const rect = area.getBoundingClientRect();
      const midP = mid(p1, p2);
      const mx = midP.x - rect.left;
      const my = midP.y - rect.top;

      const preX = (mx - startTx) / startScale;
      const preY = (my - startTy) / startScale;
      tx = mx - preX * nextScale;
      ty = my - preY * nextScale;

      scale = nextScale;
      apply();
    } else if (pts.size === 1) {
      const p = [...pts.values()][0];
      const dx = p.x - startMid.x;
      const dy = p.y - startMid.y;
      startMid = { x: p.x, y: p.y };

      if (scale > 1) {
        // 拡大中はパン
        tx += dx; ty += dy;
        apply();
      } else {
        // 等倍時はページをスクロール（ブラウザスクロールの代替）
        // dy > 0（指下）で下へスクロールしたいので -dy
        window.scrollBy(0, -dy);
      }
    }
  }

  function onPointerEnd(e) {
    pts.delete(e.pointerId);
    if (pts.size === 1) startMid = [...pts.values()][0];
    if (pts.size === 0) startMid = { x: 0, y: 0 };
  }

  area.addEventListener('pointerdown',   onPointerDown);
  area.addEventListener('pointermove',   onPointerMove);
  area.addEventListener('pointerup',     onPointerEnd);
  area.addEventListener('pointercancel', onPointerEnd);
  area.addEventListener('pointerleave',  onPointerEnd);

  // --- ホイール/トラックパッド ---
  // 拡大中はページスクロールを止め、パンに割り当て。等倍は既定動作を許可。
  area.addEventListener('wheel', (e) => {
    if (scale > 1) {
      e.preventDefault();
      tx -= e.deltaX;
      ty -= e.deltaY;
      apply();
    }
  }, { passive: false });

  // 初期適用
  apply();

  // 必要ならクリーンアップを返す
  return () => {
    area.removeEventListener('pointerdown',   onPointerDown);
    area.removeEventListener('pointermove',   onPointerMove);
    area.removeEventListener('pointerup',     onPointerEnd);
    area.removeEventListener('pointercancel', onPointerEnd);
    area.removeEventListener('pointerleave',  onPointerEnd);
  };
}

    setActive(0,false);
  </script>
</body>
</html>