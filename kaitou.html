<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>GENESIS 解答ビューア</title>
  <style>
    :root { --dock-h: 0px; --line-green: #22c55e; }

    html, body {
      margin: 0; background: #fff; color: #111;
      font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif;
      overscroll-behavior-y: contain; overflow-x: hidden; touch-action: pan-y;
    }
    .wrap { width: 100%; margin: 0 auto; padding: 0 12px; box-sizing: border-box; }

    /* ===== 固定バー（iPadの消失対策あり） ===== */
    .toc-dock {
      position: fixed; top: 0; left: 0; right: 0; z-index: 2000;
      background: #fff; border-bottom: 1px solid #eee;
      padding: 8px 0 env(safe-area-inset-top) 0;
      transform: translateZ(0); -webkit-transform: translateZ(0);
      will-change: transform;
    }
    .toc-bar { display: flex; align-items: center; gap: 10px; width: 100%; box-sizing: border-box; overflow: hidden; }
    .btn {
      height: 34px; padding: 0 12px; border: 1px solid #ddd; border-radius: 999px;
      background: #f9fafb; color: #111; cursor: pointer; font-size: 14px; text-decoration: none;
      display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0;
      -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      transition: background-color .14s ease, color .14s ease, border-color .14s ease, box-shadow .14s ease;
    }
    .btn:disabled { opacity: .4; cursor: default; }
    /* ★ オン時の見た目（text-orange-500 = #f97316 を背景色に） */
    .btn.is-on {
      background: #f97316; color: #fff; border-color: #f97316;
      box-shadow: 0 1px 2px rgba(0,0,0,.16);
    }

    .toc-container { flex: 1 1 auto; min-width: 0; overflow: hidden; }
    .toc {
      overflow-x: auto; overflow-y: hidden; white-space: nowrap;
      -webkit-overflow-scrolling: touch; scrollbar-width: none; overscroll-behavior-x: contain;
    }
    .toc::-webkit-scrollbar { display: none; }
    .toc-list { display: flex; gap: 8px; padding: 0; margin: 0; list-style: none; }
    .toc-list a {
      display: inline-block; padding: 6px 12px; border: 1px solid #ddd; border-radius: 999px;
      background: #f0f6ff; color: #0366d6; text-decoration: none; user-select: none;
      transition: background-color .12s, color .12s, border-color .12s;
    }
    .toc-list a.active { background: var(--line-green); border-color: #16a34a; color: #fff; }
    .toolbar-right { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }

    /* ===== 本文 ===== */
    main { padding-top: calc(var(--dock-h) + 12px); padding-bottom: 48px; }
    section { padding: 18px 0; border-bottom: 1px solid #f0f0f0; }

    /* ===== 画像 ===== */
    .frame {
      position: relative; overflow: hidden;
      width: 100vw; max-width: 100vw;
      margin-left: calc(50% - 50vw); margin-right: calc(50% - 50vw);
      border: 1px solid #e5e7eb; border-radius: 12px; background: #fff;
      touch-action: pan-y;
    }
    .frame img {
      display: block; width: 100%; height: auto;
      user-select: none; -webkit-user-drag: none; pointer-events: none;
      transform-origin: 0 0; will-change: transform;
    }

    /* ===== グローバル虫眼鏡 ===== */
    .magnifier {
      position: fixed; z-index: 3000; display: none;
      border: 2px solid var(--line-green); border-radius: 12px; overflow: hidden;
      box-shadow: 0 2px 6px rgba(0,0,0,.25); background: #fff;
      -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      pointer-events: none; /* レンズ自体はクリック透過 */
    }
    .magnifier img { position: absolute; left: 0; top: 0; pointer-events: none; user-select: none; -webkit-user-drag: none; }

    /* 白い丸ボタン（矢印なし） */
    .mag-controls { position: absolute; inset: 0; pointer-events: none; }
    .mag-btn {
      position: absolute;
      width: 44px; height: 44px; border-radius: 999px;
      background: #fff; border: 1px solid #ddd; box-shadow: 0 1px 2px rgba(0,0,0,.12);
      pointer-events: auto; touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none; user-select: none; -webkit-touch-callout: none;
      transition: transform .08s ease;
    }
    .mag-btn:active { transform: scale(.98); }

    .mag-btn.n  { top: 8px; left: 50%; transform: translate(-50%,0); }
    .mag-btn.s  { bottom: 8px; left: 50%; transform: translate(-50%,0); }
    .mag-btn.w  { left: 8px; top: 50%; transform: translate(0,-50%); }
    .mag-btn.e  { right: 8px; top: 50%; transform: translate(0,-50%); }
    .mag-btn.nw { top: 8px; left: 8px; }
    .mag-btn.ne { top: 8px; right: 8px; }
    .mag-btn.sw { bottom: 8px; left: 8px; }
    .mag-btn.se { bottom: 8px; right: 8px; }
  </style>
</head>
<body>
  <div class="toc-dock" id="toc-dock">
    <div class="wrap">
      <div class="toc-bar">
        <button class="btn" id="car-prev">≪</button>
        <button class="btn" id="car-next">≫</button>
        <div class="toc-container">
          <nav class="toc" id="toc"><ul class="toc-list" id="toc-list"></ul></nav>
        </div>
        <div class="toolbar-right">
          <button class="btn" id="pg-prev">←</button>
          <button class="btn" id="pg-next">→</button>
          <button class="btn" id="btn-mag">虫眼鏡</button>
          <button class="btn" id="btn-zoom">2倍</button>
          <a class="btn" id="btn-open" href="#" target="_blank" rel="noopener">原寸</a>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap" id="content"></main>

  <!-- グローバル虫眼鏡（白丸ボタンのみ） -->
  <div class="magnifier" id="global-mag">
    <img alt="" />
    <div class="mag-controls">
      <button class="mag-btn n"  aria-label="上"></button>
      <button class="mag-btn s"  aria-label="下"></button>
      <button class="mag-btn w"  aria-label="左"></button>
      <button class="mag-btn e"  aria-label="右"></button>
      <button class="mag-btn nw" aria-label="左上"></button>
      <button class="mag-btn ne" aria-label="右上"></button>
      <button class="mag-btn sw" aria-label="左下"></button>
      <button class="mag-btn se" aria-label="右下"></button>
    </div>
  </div>

  <script>
    /* ========= 画像リスト ========= */
    const BASE = "docs/";
    const groups = [
      { prefix: "1-", start: 1, end: 15 },
      { prefix: "2-", start: 1, end: 12 },
      { prefix: "3-", start: 1, end: 11 },
    ];
    const pad3 = (n) => String(n).padStart(3, "0");
    const files = groups.flatMap(g => Array.from({ length: g.end - g.start + 1 }, (_, i) => `${g.prefix}${pad3(g.start + i)}.jpeg`));

    /* ========= 要素 ========= */
    const tocEl   = document.getElementById("toc");
    const tocList = document.getElementById("toc-list");
    const content = document.getElementById("content");
    const btnOpen = document.getElementById("btn-open");
    const btnZoom = document.getElementById("btn-zoom");
    const btnMag  = document.getElementById("btn-mag");
    const pgPrev  = document.getElementById("pg-prev");
    const pgNext  = document.getElementById("pg-next");
    const carPrev = document.getElementById("car-prev");
    const carNext = document.getElementById("car-next");
    const dockEl  = document.getElementById("toc-dock");

    /* ========= DOM生成 ========= */
    files.forEach((name, idx) => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      a.href = `#p-${name.replace(/\.[^.]+$/, "")}`;
      a.dataset.index = idx;
      a.textContent = name.replace(".jpeg", "");
      if (idx === 0) a.classList.add("active");
      li.appendChild(a); tocList.appendChild(li);

      const sec = document.createElement("section");
      sec.dataset.index = idx;
      sec.id = `p-${name.replace(/\.[^.]+$/, "")}`;
      sec.innerHTML = `<figure class="frame"><img src="${BASE}${encodeURIComponent(name)}" alt=""></figure>`;
      content.appendChild(sec);
    });

    /* ========= 高さ更新 ========= */
    function applyDockH() {
      document.documentElement.style.setProperty("--dock-h", (dockEl?.offsetHeight || 0) + "px");
    }
    new ResizeObserver(applyDockH).observe(dockEl);
    window.addEventListener("resize", applyDockH);
    applyDockH();

    const sections = Array.from(document.querySelectorAll("main section"));
    const tocLinks = Array.from(document.querySelectorAll("#toc-list a"));
    let currentIndex = 0;

    /* ========= 現在地判定 ========= */
    function detectCurrentPage() {
      const baseline = dockEl.getBoundingClientRect().bottom;
      let idx = 0;
      for (let i = 0; i < sections.length; i++) {
        const r = sections[i].getBoundingClientRect();
        const th = r.top + r.height * 0.6;
        if (baseline >= th) idx = i + 1;
      }
      const last = sections[sections.length - 1].getBoundingClientRect();
      if (last.bottom <= window.innerHeight) idx = sections.length - 1;
      if (idx >= sections.length) idx = sections.length - 1;
      if (idx !== currentIndex) setActive(idx);
    }
    function ensureActiveLinkVisible() {
      const link = tocLinks[currentIndex];
      if (!link) return;
      const lr = link.getBoundingClientRect();
      const tr = tocEl.getBoundingClientRect();
      if (lr.left < tr.left || lr.right > tr.right) {
        link.scrollIntoView({ inline: 'nearest', block: 'nearest', behavior: 'auto' });
      }
    }
    function setActive(i) {
      currentIndex = i;
      tocLinks.forEach((el, idx) => el.classList.toggle("active", idx === i));
      ensureActiveLinkVisible();
      const img = sections[i]?.querySelector("img");
      if (img) btnOpen.href = img.currentSrc || img.src;

      if (magState.on) {
        magState.frame = sections[i].querySelector(".frame");
        resetMagStateToCenter();
        renderMagnifier();
      }
    }
    window.addEventListener("scroll", detectCurrentPage, { passive: true });
    window.addEventListener("resize", detectCurrentPage);
    window.addEventListener("load", detectCurrentPage);

    /* ========= 共通：ズーム/虫眼鏡の一括OFF（ボタン外操作の前に呼ぶ） ========= */
    function deactivateAll() {
      if (zoomState.on) exitZoom(zoomState.frame);
      if (magState.on)  exitMagnifier();
    }
    function setBtnHighlight() {
      btnMag.classList.toggle('is-on', magState.on);
      btnZoom.classList.toggle('is-on', zoomState.on);
    }

    /* ========= ページ移動 ========= */
    function scrollToSection(i) {
      const s = sections[i]; if (!s) return;
      window.scrollTo({ top: s.offsetTop, behavior: "auto" });
      requestAnimationFrame(() => { detectCurrentPage(); ensureActiveLinkVisible(); });
    }
    function movePrevWithPin(){ const next = Math.max(0, currentIndex - 1); scrollToSection(next); }
    function moveNextWithPin(){ const next = Math.min(sections.length - 1, currentIndex + 1); scrollToSection(next); }
    pgPrev.onclick = () => { deactivateAll(); movePrevWithPin(); };
    pgNext.onclick = () => { deactivateAll(); moveNextWithPin(); };
    tocLinks.forEach(a => a.onclick = (e) => { e.preventDefault(); deactivateAll(); scrollToSection(Number(a.dataset.index)); });

    /* ======== カルーセル送り ======== */
    function pageSize() { return Math.max(200, tocEl.clientWidth * 0.8); }
    carPrev.onclick = () => { deactivateAll(); tocEl.scrollBy({ left: -pageSize(), behavior: "auto" }); };
    carNext.onclick = () => { deactivateAll(); tocEl.scrollBy({ left:  pageSize(), behavior: "auto" }); };

    /* ========= グローバル虫眼鏡 ========= */
    const magEl = document.getElementById('global-mag');
    const magImg = magEl.querySelector('img');
    const magState = { on: false, frame: null, cx: 0, cy: 0, scale: 2 };

    // iPhone縦長なら3倍
    function isIPhonePortrait() {
      return /iPhone/i.test(navigator.userAgent) && window.matchMedia("(orientation: portrait)").matches;
    }
    function updateMagScale() { magState.scale = isIPhonePortrait() ? 3 : 2; }

    function visibleAreaBounds() {
      return { left: 0, right: window.innerWidth,
        top:  document.getElementById("toc-dock").getBoundingClientRect().bottom,
        bottom: window.innerHeight };
    }
    function sizeMagnifierTwoThirds() {
      const vb = visibleAreaBounds();
      magEl.style.width  = Math.round(((vb.right - vb.left) * 2) / 3) + "px";
      magEl.style.height = Math.round(((vb.bottom - vb.top) * 2) / 3) + "px";
    }
    function centerMagnifier() {
      const vb = visibleAreaBounds();
      const w = magEl.offsetWidth, h = magEl.offsetHeight;
      magEl.style.left = Math.round((vb.left + vb.right - w) / 2) + "px";
      magEl.style.top  = Math.round((vb.top  + vb.bottom - h) / 2) + "px";
    }
    function lockScroll(){ document.body.style.overflow="hidden"; document.body.style.touchAction="none"; }
    function unlockScroll(){ document.body.style.overflow=""; document.body.style.touchAction=""; }
    function resetMagStateToCenter() {
      const img = magState.frame.querySelector("img");
      const iw = img.clientWidth, ih = img.clientHeight;
      magState.cx = iw/2; magState.cy = ih/2;
    }
    function renderMagnifier() {
      if (!magState.on || !magState.frame) return;
      const img = magState.frame.querySelector("img");
      const iw = img.clientWidth, ih = img.clientHeight;
      const w = magEl.clientWidth, h = magEl.clientHeight;
      const src = img.currentSrc || img.src; if (magImg.src !== src) magImg.src = src;

      const s = magState.scale;
      const imgW = iw*s, imgH = ih*s;
      magImg.style.width = imgW+"px"; magImg.style.height = imgH+"px";

      let offX = Math.round(w/2 - magState.cx*s);
      let offY = Math.round(h/2 - magState.cy*s);
      const minX = w - imgW, maxX = 0;
      const minY = h - imgH, maxY = 0;
      offX = Math.max(minX, Math.min(maxX, offX));
      offY = Math.max(minY, Math.min(maxY, offY));
      magImg.style.transform = `translate(${offX}px, ${offY}px)`;
      setBtnHighlight();
    }

    function enterMagnifier(frame) {
      if (zoomState.on) exitZoom(zoomState.frame);
      magState.on = true; magState.frame = frame;
      sizeMagnifierTwoThirds(); magEl.style.display = "block"; centerMagnifier();
      updateMagScale(); resetMagStateToCenter(); renderMagnifier();
      lockScroll(); setBtnHighlight();

      const step = () => {
        const img = magState.frame.querySelector("img");
        const iw = img.clientWidth, ih = img.clientHeight;
        return Math.max(12, Math.round(Math.min(iw, ih)/18));
      };
      const moveBy = (dx,dy) => {
        const img = magState.frame.querySelector("img");
        const iw = img.clientWidth, ih = img.clientHeight;
        const sp = step();
        magState.cx = Math.max(0, Math.min(iw, magState.cx + dx*sp));
        magState.cy = Math.max(0, Math.min(ih, magState.cy + dy*sp));
        renderMagnifier();
      };
      const map = { n:[0,-1], s:[0,1], w:[-1,0], e:[1,0], nw:[-1,-1], ne:[1,-1], sw:[-1,1], se:[1,1] };
      magEl.querySelectorAll(".mag-btn").forEach(btn=>{
        const dir = Array.from(btn.classList).find(c=>map[c]); const [dx,dy]=map[dir];
        let t, run=false;
        const once=()=>moveBy(dx,dy);
        const start=(e)=>{ e.preventDefault(); if(run) return; run=true; once(); t=setInterval(once,50); };
        const stop=()=>{ run=false; clearInterval(t); };
        btn.addEventListener("pointerdown",start);
        btn.addEventListener("pointerup",stop);
        btn.addEventListener("pointercancel",stop);
        btn.addEventListener("pointerleave",stop);
      });

      const onResize = () => { sizeMagnifierTwoThirds(); centerMagnifier(); updateMagScale(); renderMagnifier(); };
      window.addEventListener("resize", onResize, { passive: true });
      magEl._onResize = onResize;
    }

    function exitMagnifier() {
      magState.on = false; magEl.style.display = "none";
      if (magEl._onResize) { window.removeEventListener("resize", magEl._onResize); magEl._onResize=null; }
      unlockScroll(); setBtnHighlight();
    }

    document.getElementById("btn-mag").onclick = () => {
      const f = sections[currentIndex].querySelector(".frame");
      if (magState.on) exitMagnifier(); else enterMagnifier(f);
    };

    /* ========= 2倍ズーム（表示サイズ基準で厳密クランプ） ========= */
    const zoomState = { on:false, frame:null, scale:2, cx:0, cy:0 };

    function renderZoom() {
      if (!zoomState.on) return;
      const frame = zoomState.frame; const img = frame.querySelector('img');
      const w = frame.clientWidth, h = frame.clientHeight;
      const iw = img.clientWidth, ih = img.clientHeight;
      const s = zoomState.scale;
      const imgW = iw*s, imgH = ih*s;

      let offX = Math.round(w/2 - zoomState.cx*s);
      let offY = Math.round(h/2 - zoomState.cy*s);
      const minX = w - imgW, maxX = 0;
      const minY = h - imgH, maxY = 0;
      offX = Math.max(minX, Math.min(maxX, offX));
      offY = Math.max(minY, Math.min(maxY, offY));

      img.style.transform = `translate(${offX}px, ${offY}px) scale(${s})`;
      setBtnHighlight();
    }

    function enterZoom(frame) {
      if (magState.on) exitMagnifier();
      const img = frame.querySelector('img');
      zoomState.on = true; zoomState.frame = frame; zoomState.scale = 2;

      const iw = img.clientWidth, ih = img.clientHeight;
      zoomState.cx = iw/2; zoomState.cy = ih/2;

      frame.style.touchAction = "none";
      let px=null, py=null;
      frame.onpointerdown = (e)=>{ px=e.clientX; py=e.clientY; frame.setPointerCapture(e.pointerId); };
      frame.onpointermove = (e)=>{
        if (px==null) return;
        const dx = e.clientX - px, dy = e.clientY - py;
        zoomState.cx -= dx/zoomState.scale;
        zoomState.cy -= dy/zoomState.scale;

        const iwNow = img.clientWidth, ihNow = img.clientHeight;
        zoomState.cx = Math.max(0, Math.min(iwNow,  zoomState.cx));
        zoomState.cy = Math.max(0, Math.min(ihNow, zoomState.cy));

        px=e.clientX; py=e.clientY;
        renderZoom();
      };
      frame.onpointerup = (e)=>{ px=null; try{ frame.releasePointerCapture(e.pointerId);}catch{} };
      renderZoom();
    }

    function exitZoom(frame) {
      const f = frame || zoomState.frame; if (!f) return;
      const img = f.querySelector('img');
      img.style.transform = "scale(1)";
      f.style.touchAction = "pan-y";
      f.onpointerdown = f.onpointermove = f.onpointerup = null;
      zoomState.on = false; zoomState.frame = null;
      setBtnHighlight();
    }

    btnZoom.onclick = () => {
      const f = sections[currentIndex].querySelector(".frame");
      if (zoomState.on && zoomState.frame !== f) exitZoom(zoomState.frame);
      if (!zoomState.on) enterZoom(f); else exitZoom(f);
    };
  </script>
</body>
</html>