<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GENESIS 解答ビューア</title>
  <style>
    :root { --wrap-w: 1100px; --gap: 16px; --header-h: 0px; }
    /* レイアウト */
    body { margin: 0; font-family: system-ui, -apple-system, "Noto Sans JP", sans-serif; color:#111; line-height:1.6; }
    header { position: sticky; top: 0; z-index: 20; background: rgba(255,255,255,.92); backdrop-filter: blur(8px); border-bottom: 1px solid #eee; }
    .wrap { max-width: var(--wrap-w); margin: 0 auto; padding: 14px; }
    h1 { font-size: 1.1rem; margin: 0 0 8px; }
    main { padding-bottom: 60px; }
    section { padding: 22px 0; border-bottom: 1px solid #f5f5f5; scroll-margin-top: calc(var(--header-h) + 8px); }
    section h2 { font-size:.95rem; margin:0 0 8px; color:#333; }
    figure { margin:0; }
    .hint { font-size:.85rem; color:#666; margin:6px 0 0; }
    .tools { display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 0; }
    .tools a { font-size:.9rem; text-decoration:none; color:#333; padding:6px 10px; border:1px solid #e5e7eb; border-radius:8px; background:#fafafa; }
    .toplink { text-align:right; margin-top:8px; }
    .toplink a { text-decoration:none; color:#06f; }

    /* 画像フレーム（ピンチズーム対応） */
    .frame { width:100%; overflow:hidden; border:1px solid #e5e7eb; border-radius:12px; background:#fff; touch-action: none; }
    .frame img { display:block; width:100%; height:auto; user-select:none; -webkit-user-drag:none; touch-action: none; transform-origin: 0 0; }

    /* === 目次カルーセル === */
    .toc-wrap{position:relative; display:flex; align-items:center; gap:8px}
    .toc{
      flex:1 1 auto; overflow-x:auto; overflow-y:hidden; white-space:nowrap;
      scroll-snap-type:x mandatory; scrollbar-width:none;
    }
    .toc::-webkit-scrollbar{display:none}
    .toc-list{display:flex; gap:8px; padding:0; margin:0; list-style:none}
    .toc-list a{
      display:inline-block; padding:6px 12px; border:1px solid #ddd; border-radius:999px;
      background:#f9fbff; color:#0366d6; text-decoration:none; scroll-snap-align:start;
    }
    .toc-list a:focus-visible{outline:3px solid #22c55e; outline-offset:2px}
    .toc-arrow{
      flex:0 0 auto; width:34px; height:34px; border:1px solid #ddd; border-radius:999px;
      background:#fff; cursor:pointer; line-height:1; font-size:18px; color:#333;
    }
    .toc-arrow:disabled{opacity:.35; cursor:default}
    @media (max-width: 640px) { .wrap{padding:12px} }
  </style>
</head>
<body>
<header id="top">
  <div class="wrap">
    <h1>解答画像ビューア（カルーセル目次 / ピンチズーム対応）</h1>
    <div class="toc-wrap" role="region" aria-label="目次">
      <button class="toc-arrow prev" aria-label="左へ">‹</button>
      <nav class="toc" id="toc" aria-label="目次（横スクロール）">
        <ul class="toc-list" id="toc-list"></ul>
      </nav>
      <button class="toc-arrow next" aria-label="右へ">›</button>
    </div>
  </div>
</header>

<main class="wrap" id="content">
  <!-- JSで自動生成 -->
</main>

<script>
  // ===== 設定 =====
  const BASE = "docs/"; // 画像フォルダ
  // 枚数はここを調整：1-001..1-015, 2-001..2-012, 3-001..3-011 の例
  const groups = [
    { prefix: "1-", start: 1, end: 15 },
    { prefix: "2-", start: 1, end: 12 },
    { prefix: "3-", start: 1, end: 11 },
  ];

  // ===== 生成 =====
  const pad3 = n => String(n).padStart(3, "0");
  const files = groups.flatMap(g => Array.from({length: g.end - g.start + 1}, (_,i)=>`${g.prefix}${pad3(g.start+i)}.jpeg`));

  const tocList = document.getElementById("toc-list");
  const content = document.getElementById("content");

  files.forEach((name, idx) => {
    const id = `p-${name.replace(/\.[^.]+$/, "")}`; // p-1-001 など

    // TOC
    const li = document.createElement("li");
    const a = document.createElement("a");
    a.href = `#${id}`;
    a.textContent = name.replace(".jpeg","");
    li.appendChild(a);
    tocList.appendChild(li);

    // Section
    const sec = document.createElement("section");
    sec.id = id;
    sec.innerHTML = `
      <h2>${idx+1}. ${name}</h2>
      <figure class="frame" data-zoomable>
        <img src="${BASE}${encodeURIComponent(name)}" alt="${name}">
      </figure>
      <p class="hint">ピンチで拡大／2本指ドラッグで移動／ダブルタップでリセット</p>
      <div class="tools">
        <a href="${BASE}${encodeURIComponent(name)}" download>画像をダウンロード</a>
        <a href="${BASE}${encodeURIComponent(name)}" target="_blank" rel="noopener">原寸で開く</a>
      </div>
      <p class="toplink"><a href="#top">▲ 目次へ戻る</a></p>
    `;
    content.appendChild(sec);
  });

  // ===== ヘッダー高さをCSS変数に反映（可変行対応） =====
  const headerEl = document.querySelector('header#top');
  function applyHeaderHeightVar() {
    const h = headerEl?.offsetHeight || 0;
    document.documentElement.style.setProperty('--header-h', h + 'px');
  }
  applyHeaderHeightVar();
  new ResizeObserver(applyHeaderHeightVar).observe(headerEl);
  window.addEventListener('resize', applyHeaderHeightVar);

  // ===== 目次カルーセル制御 =====
  const tocEl = document.getElementById('toc');
  const prevBtn = document.querySelector('.toc-arrow.prev');
  const nextBtn = document.querySelector('.toc-arrow.next');

  function pageSize(){ return Math.max(200, tocEl.clientWidth * 0.8); }
  function updateArrows(){
    const max = tocEl.scrollWidth - tocEl.clientWidth - 1;
    prevBtn.disabled = tocEl.scrollLeft <= 0;
    nextBtn.disabled = tocEl.scrollLeft >= max;
  }
  prevBtn.addEventListener('click', () => { tocEl.scrollBy({left: -pageSize(), behavior:'smooth'}); });
  nextBtn.addEventListener('click', () => { tocEl.scrollBy({left:  pageSize(), behavior:'smooth'}); });
  tocEl.addEventListener('scroll', updateArrows);
  window.addEventListener('resize', updateArrows);
  updateArrows();

  // ホイール縦→横
  tocEl.addEventListener('wheel', (e) => {
    if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
      tocEl.scrollBy({ left: e.deltaY, behavior: 'auto' });
      e.preventDefault();
    }
  }, { passive:false });

  // ドラッグ/フリック
  (() => {
    let isDown=false, startX=0, startLeft=0;
    tocEl.addEventListener('pointerdown', e => {
      isDown = true; startX = e.clientX; startLeft = tocEl.scrollLeft;
      tocEl.setPointerCapture(e.pointerId);
    });
    tocEl.addEventListener('pointermove', e => {
      if(!isDown) return;
      const dx = e.clientX - startX;
      tocEl.scrollLeft = startLeft - dx;
    });
    const end = () => { isDown=false; };
    tocEl.addEventListener('pointerup', end);
    tocEl.addEventListener('pointercancel', end);
    tocEl.addEventListener('pointerleave', end);
  })();

  // フォーカス時に見える位置へ
  tocList.addEventListener('focusin', e => {
    if (e.target.tagName === 'A') e.target.scrollIntoView({ inline:'nearest', block:'nearest' });
  });

  // ===== アンカー移動：ヘッダー下端にピッタリ合わせる =====
  document.querySelectorAll('a[href^="#"]').forEach(a => {
    a.addEventListener('click', e => {
      const id = a.getAttribute('href');
      const target = document.querySelector(id);
      if (!target) return;
      e.preventDefault();
      const headerH = headerEl?.offsetHeight || 0;
      const y = target.getBoundingClientRect().top + window.scrollY - headerH - 8;
      window.scrollTo({ top: y, behavior: 'smooth' });
      history.pushState(null, "", id);
    });
  });

  // ===== 画像ピンチズーム（Pointer Events） =====
  document.querySelectorAll('[data-zoomable]').forEach(initZoomable);

  function initZoomable(frame){
    const img = frame.querySelector('img');
    let pointers = new Map();
    let baseScale = 1, baseX = 0, baseY = 0;
    let liveScale = 1, liveX = 0, liveY = 0;
    let lastTap = 0, pinchStart = null;

    const setTransform = () => {
      const s = baseScale * liveScale;
      const tx = baseX + liveX;
      const ty = baseY + liveY;
      img.style.transform = `translate(${tx}px, ${ty}px) scale(${s})`;
    };
    const rectPt = (cx,cy)=>{ const r=frame.getBoundingClientRect(); return {x: cx - r.left, y: cy - r.top}; };
    const dist = (a,b)=> Math.hypot(a.x-b.x, a.y-b.y);
    const mid  = (a,b)=> ({ x:(a.x+b.x)/2, y:(a.y+b.y)/2 });

    frame.addEventListener('pointerdown', e => {
      frame.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId, rectPt(e.clientX, e.clientY));

      const now = performance.now();
      if (now - lastTap < 300 && pointers.size === 1) {
        baseScale = 1; baseX = 0; baseY = 0; liveScale = 1; liveX = 0; liveY = 0; pinchStart = null;
        img.style.transformOrigin = "0 0";
        setTransform(); lastTap = 0; return;
      }
      lastTap = now;
    });

    frame.addEventListener('pointermove', e => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, rectPt(e.clientX, e.clientY));

      if (pointers.size === 2) {
        const [p1, p2] = [...pointers.values()];
        const m = mid(p1,p2);
        const d = dist(p1,p2);
        if (!pinchStart) {
          pinchStart = { d, m, bs: baseScale, bx: baseX, by: baseY };
          const ox = (m.x - baseX) / baseScale;
          const oy = (m.y - baseY) / baseScale;
          img.style.transformOrigin = `${ox}px ${oy}px`;
        } else {
          liveScale = d / pinchStart.d;
          liveX = (m.x - pinchStart.m.x);
          liveY = (m.y - pinchStart.m.y);
        }
        setTransform();
      } else if (pointers.size === 1 && !pinchStart) {
        const p = [...pointers.values()][0];
        liveX = p._lx !== undefined ? (p.x - p._lx) : 0;
        liveY = p._ly !== undefined ? (p.y - p._ly) : 0;
        p._lx = p.x; p._ly = p.y;
        setTransform();
      }
    });

    function endGesture(id){
      const hadTwo = pointers.size === 2;
      pointers.delete(id);
      if (hadTwo || pinchStart) {
        baseScale *= liveScale; baseX += liveX; baseY += liveY;
        liveScale = 1; liveX = 0; liveY = 0; pinchStart = null; setTransform();
      } else if (liveX || liveY) {
        baseX += liveX; baseY += liveY; liveX = 0; liveY = 0; setTransform();
      }
    }
    frame.addEventListener('pointerup', e => endGesture(e.pointerId));
    frame.addEventListener('pointercancel', e => endGesture(e.pointerId));

    frame.addEventListener('wheel', e => {
      if (!e.ctrlKey) return;
      e.preventDefault();
      const { x, y } = rectPt(e.clientX, e.clientY);
      const scaleDelta = Math.exp(-e.deltaY * 0.002);
      const ox = (x - baseX) / baseScale;
      const oy = (y - baseY) / baseScale;
      img.style.transformOrigin = `${ox}px ${oy}px`;
      baseScale *= scaleDelta;
      setTransform();
    }, { passive:false });
  }
</script>
</body>
</html>
